"""Spectra functions."""

import numpy as _np
import matplotlib.pyplot as _plt
from spectrainterface.accelerator import StorageRingParameters
import mathphys
from spectrainterface.tools import SourceFunctions
from spectrainterface.sources import Undulator
import json
from spectrainterface import spectra
import sys
import time
import os
import multiprocessing

# REPOS_PATH = os.path.abspath("./")
# REPOS_PATH = __file__
REPOS_PATH = os.path.dirname(os.path.abspath(__file__))

ECHARGE = mathphys.constants.elementary_charge
EMASS = mathphys.constants.electron_mass
LSPEED = mathphys.constants.light_speed
ECHARGE_MC = ECHARGE / (2 * _np.pi * EMASS * LSPEED)
PLANCK = mathphys.constants.reduced_planck_constant


class SpectraTools:
    """Class with general spectra tools."""

    @staticmethod
    def _run_solver(input_template, verbose=False):
        """Run spectra.

        Args:
            input_template (dict): Dictionary containing
            calculation parameters.
            verbose (bool): If true it will print elapsed time

        Returns:
            dict: Output data dictionary
        """
        input_str = json.dumps(input_template)

        # call solver with the input string (JSON format)
        solver = spectra.Solver(input_str)

        # check if the parameter load is OK
        isready = solver.IsReady()
        if isready is False:
            print("Parameter load failed.")
            sys.exit()

        t0 = time.time()
        # start calculation
        solver.Run()
        dt = time.time() - t0
        if verbose:
            print("elapsed time: {0:.1f} s".format(dt))
        return solver

    @staticmethod
    def _set_accelerator_config(accelerator, input_template, flag_bend):
        input_template["Accelerator"]["Energy (GeV)"] = accelerator.energy
        input_template["Accelerator"]["Current (mA)"] = accelerator.current

        input_template["Accelerator"]["&sigma;<sub>z</sub> (mm)"] = (
            accelerator.sigmaz
        )

        input_template["Accelerator"]["Nat. Emittance (m.rad)"] = (
            accelerator.nat_emittance
        )

        input_template["Accelerator"]["Coupling Constant"] = (
            accelerator.coupling_constant
        )

        input_template["Accelerator"]["Energy Spread"] = (
            accelerator.energy_spread
        )

        input_template["Accelerator"]["&beta;<sub>x,y</sub> (m)"] = [
            accelerator.betax,
            accelerator.betay,
        ]

        input_template["Accelerator"]["&alpha;<sub>x,y</sub>"] = [
            accelerator.alphax,
            accelerator.alphay,
        ]

        input_template["Accelerator"]["&eta;<sub>x,y</sub> (m)"] = [
            accelerator.etax,
            accelerator.etay,
        ]

        input_template["Accelerator"]["&eta;'<sub>x,y</sub>"] = [
            accelerator.etapx,
            accelerator.etapy,
        ]

        input_template["Accelerator"]["Options"]["Injection Condition"] = (
            accelerator.injection_condition
        )

        input_template["Accelerator"]["Options"]["Zero Emittance"] = (
            accelerator.zero_emittance
        )

        input_template["Accelerator"]["Options"]["Zero Energy Spread"] = (
            accelerator.zero_energy_spread
        )
        if flag_bend:
            input_template["Accelerator"]["Options"]["Injection Condition"] = (
                "Align at Center"
            )
        else:
            input_template["Accelerator"]["Options"]["Injection Condition"] = (
                "Align at Entrance"
            )

        return input_template


class GeneralConfigs(SourceFunctions):
    """Class with general configs."""

    class SourceType:
        """Sub class to define source type."""

        user_defined = "userdefined"
        horizontal_undulator = "linearundulator"
        vertical_undulator = "verticalundulator"
        helical_undulator = "helicalundulator"
        elliptic_undulator = "ellipticundulator"
        figure8_undulator = "figure8undulator"
        vertical_figure8_undulator = "verticalfigure8undulator"
        bending_magnet = "bendingmagnet"
        wiggler = "wiggler"

    def __init__(self):
        """Class constructor."""
        self._distance_from_source = 10  # [m]
        self._source_type = self.SourceType.user_defined
        self._field = None
        self._length = None
        self._bx_peak = None
        self._by_peak = None
        self._period = None
        self._kx = None
        self._ky = None
        self._rho = None

    @property
    def source_type(self):
        """Source type.

        Returns:
            CalcConfigs variables: Magnetic field, it can be defined by user or
            generated by spectra.
        """
        return self._source_type

    @property
    def field(self):
        """Magnetic field defined by user.

        Returns:
            numpy array: First column contains longitudinal spatial
            coordinate (z) [mm], second column contais vertical field
            [T], and third column constais horizontal field [T].
        """
        return self._field

    @property
    def length(self):
        """Length of device.

        Returns:
            float: Length [m]
        """
        return self._length

    @property
    def period(self):
        """Insertion device period [mm].

        Returns:
            float: ID's period [mm]
        """
        return self._period

    @property
    def by_peak(self):
        """Insertion device vertical peak field [T].

        Returns:
            float: by peak field [T]
        """
        return self._by_peak

    @property
    def bx_peak(self):
        """Insertion device horizontal peak field [T].

        Returns:
            float: bx peak field [T]
        """
        return self._bx_peak

    @property
    def ky(self):
        """Vertical deflection parameter (Ky).

        Returns:
            float: Vertical deflection parameter
        """
        return self._ky

    @property
    def kx(self):
        """Horizontal deflection parameter (Kx).

        Returns:
            float: Horizontal deflection parameter
        """
        return self._kx

    @property
    def rho(self):
        """Curvature radius.

        Returns:
            float: Curvature radius [m]
        """
        return self._rho

    @property
    def distance_from_source(self):
        """Distance from source.

        Returns:
            float: Distance from source [m]
        """
        return self._distance_from_source

    @source_type.setter
    def source_type(self, value):
        self._source_type = value

    @field.setter
    def field(self, value):
        if self.source_type != self.SourceType.user_defined:
            raise ValueError(
                "Field can only be defined if source type is user_defined."
            )
        else:
            self._field = value

    @length.setter
    def length(self, value):
        self._length = value

    @period.setter
    def period(self, value):
        if (
            self.source_type == self.SourceType.user_defined
            or self.source_type == self.SourceType.bending_magnet
        ):
            raise ValueError(
                "Period can only be defined if source type is not user_defined or is not a bending."  # noqa: E501
            )
        else:
            self._period = value
            if self._bx_peak is not None:
                self._kx = 1e-3 * ECHARGE_MC * self._bx_peak * self.period
            if self._by_peak is not None:
                self._ky = 1e-3 * ECHARGE_MC * self._by_peak * self.period
            if self._kx is not None:
                self._bx_peak = self._kx / (ECHARGE_MC * 1e-3 * self.period)
            if self._ky is not None:
                self._by_peak = self._ky / (ECHARGE_MC * 1e-3 * self.period)

    @by_peak.setter
    def by_peak(self, value):
        if self.source_type == self.SourceType.user_defined:
            raise ValueError(
                "By peak can only be defined if source type is not user_defined."  # noqa: E501
            )
        elif self.source_type == self.SourceType.vertical_undulator:
            raise ValueError(
                "By peak can not be defined if source type is a vertical undulator."  # noqa: E501
            )
        else:
            self._by_peak = value
            if self.period is not None:
                self._ky = 1e-3 * ECHARGE_MC * self._by_peak * self.period
                if (
                    self.source_type
                    == self.SourceType.vertical_figure8_undulator
                ):
                    self._ky *= 2

            if self.source_type == self.SourceType.helical_undulator:
                self._bx_peak = value
                if self.period is not None:
                    self._kx = self.ky

    @bx_peak.setter
    def bx_peak(self, value):
        if self.source_type == self.SourceType.user_defined:
            raise ValueError(
                "Bx peak can only be defined if source type is not user_defined."  # noqa: E501
            )
        elif self.source_type == self.SourceType.horizontal_undulator:
            raise ValueError(
                "Bx peak can not be defined if source type is a horizontal undulator."  # noqa: E501
            )
        else:
            self._bx_peak = value
            if self.period is not None:
                self._kx = 1e-3 * ECHARGE_MC * self._bx_peak * self.period
                if self.source_type == self.SourceType.figure8_undulator:
                    self._kx *= 2

            if self.source_type == self.SourceType.helical_undulator:
                self._by_peak = value
                if self.period is not None:
                    self._ky = self.kx

    @ky.setter
    def ky(self, value):
        if self.source_type == self.SourceType.user_defined:
            raise ValueError(
                "Ky can only be defined if source type is not user_defined."  # noqa: E501
            )
        elif self.source_type == self.SourceType.vertical_undulator:
            raise ValueError(
                "Ky can not be defined if source type is a vertical undulator."
            )  # noqa: E501
        else:
            self._ky = value
            if self.period is not None:
                self._by_peak = self._ky / (ECHARGE_MC * 1e-3 * self.period)
                if (
                    self.source_type
                    == self.SourceType.vertical_figure8_undulator
                ):
                    self._by_peak /= 2

            if self.source_type == self.SourceType.helical_undulator:
                self._kx = value
                if self.period is not None:
                    self._bx_peak = self.bx_peak

    @kx.setter
    def kx(self, value):
        if self.source_type == self.SourceType.user_defined:
            raise ValueError(
                "Kx can only be defined if source type is not user_defined."  # noqa: E501
            )
        elif self.source_type == self.SourceType.horizontal_undulator:
            raise ValueError(
                "Kx can not be defined if source type is a horizontal undulator."  # noqa: E501
            )
        else:
            self._kx = value
            if self.period is not None:
                self._bx_peak = self._kx / (ECHARGE_MC * 1e-3 * self.period)
                if self.source_type == self.SourceType.figure8_undulator:
                    self._bx_peak /= 2

            if self.source_type == self.SourceType.helical_undulator:
                self._kx = value
                if self.period is not None:
                    self._bx_peak = self.bx_peak

    @rho.setter
    def rho(self, value):
        if self.source_type == self.SourceType.bending_magnet:
            self._rho = value
        else:
            raise ValueError(
                "Curvature radius can only be defined if source is a bending magnet."  # noqa: E501
            )

    @distance_from_source.setter
    def distance_from_source(self, value):
        self._distance_from_source = value


class Calc(GeneralConfigs, SpectraTools):
    """Class with methods to calculate flux."""

    class CalcConfigs:
        """Sub class to define calculation parameters."""

        class Method:
            """Sub class to define calculation method."""

            near_field = "nearfield"
            far_field = "farfield"
            wigner = "wigner"

        class Variable:
            """Sub class to define independet variable."""

            energy = "en"
            mesh_xy = "xy"
            k = "k"

        class Output:
            """Sub class to define output type."""

            flux_density = "fluxdensity"
            flux = "partialflux"
            brilliance = "brilliance"
            power_density = "powerdensity"

        class SlitShape:
            """Sub class to define slit shape."""

            none = ""
            circular = "circslit"
            rectangular = "retslit"

    def __init__(self, accelerator):
        """Class constructor."""
        super().__init__()
        self._method = self.CalcConfigs.Method.near_field
        self._indep_var = self.CalcConfigs.Variable.energy
        self._output_type = self.CalcConfigs.Output.flux_density
        self._slit_shape = self.CalcConfigs.SlitShape.none
        self._accelerator = accelerator
        self._input_template = None

        # Energy related
        self._energy_range = None
        self._energy_step = None
        self._slit_position = None
        self._slit_acceptance = None

        #  Mesh xy related
        self._target_energy = None
        self._x_range = None
        self._y_range = None
        self._x_nr_pts = None
        self._y_nr_pts = None

        #  K related
        self._harmonic_range = None
        self._k_range = None
        self._k_nr_pts = None
        self._slice_x = None
        self._slice_y = None
        self._slice_px = None
        self._slice_py = None

        #  Phase error
        self._add_phase_errors = False
        self._user_recovery_params = True

        # Output
        self._output_captions = None
        self._output_data = None
        self._output_variables = None

        self._flux = None
        self._power_density = None
        self._brilliance = None
        self._pl = None
        self._pc = None
        self._pl45 = None
        self._energies = None
        self._x = None
        self._y = None
        self._k = None
        self._output_kx = None
        self._output_ky = None

    @property
    def method(self):
        """Method of calculation.

        Returns:
            CalcConfigs variables: Method of calculation, it can be near field
            or wigner functions, for example.
        """
        return self._method

    @property
    def indep_var(self):
        """Independent variable.

        Returns:
            CalcConfigs variables: Independet variable, it can be energy of a
            mesh in the xy plane
        """
        return self._indep_var

    @property
    def output_type(self):
        """Output type.

        Returns:
            CalcConfigs variables: Output type, it can be flux density or
            partial flux, for example.
        """
        return self._output_type

    @property
    def energy_range(self):
        """Energy range.

        Returns:
            List of ints: Energy range to calculate spectrum
             [initial point, final point].
        """
        return self._energy_range

    @property
    def energy_step(self):
        """Energy step.

        Returns:
            float: Spectrum energy step.
        """
        return self._energy_step

    @property
    def observation_angle(self):
        """Observation position [mrad].

        Returns:
            List of floats: Slit position [xpos, ypos] [mrad]
        """
        return self._slit_position

    @property
    def slit_acceptance(self):
        """Slit acceptance [mrad].

        Returns:
            List of floats: Slit acceptance [xpos, ypos] [mrad]
        """
        return self._slit_acceptance

    @property
    def slit_shape(self):
        """Slit shape.

        Returns:
            string: It can be circular or rectangular.
        """
        return self._slit_shape

    @property
    def target_energy(self):
        """Target energy.

        Returns:
            float: Target energy to analyse.
        """
        return self._target_energy

    @property
    def x_range(self):
        """Mesh x range.

        Returns:
            List of floats: x limits [mrad] [initial point, final point]
        """
        return self._x_range

    @property
    def y_range(self):
        """Mesh y range.

        Returns:
            List of floats: y limits [mrad] [initial point, final point]
        """
        return self._y_range

    @property
    def x_nr_pts(self):
        """Nr of x points.

        Returns:
            float: Number of horizontal mesh points
        """
        return self._x_nr_pts

    @property
    def y_nr_pts(self):
        """Nr of y points.

        Returns:
            float: Number of vertical mesh points
        """
        return self._y_nr_pts

    @property
    def harmonic_range(self):
        """Harmonic range.

        Returns:
            list of ints: List of harmonics to calculate brilliance.
        """
        return self._harmonic_range

    @property
    def k_range(self):
        """K range.

        Returns:
            list of ints: List of k to calculate brilliance [kmin, kmax].
        """
        return self._k_range

    @property
    def k_nr_pts(self):
        """Number of k points.

        Returns:
            int: Number of K points.
        """
        return self._k_nr_pts

    @property
    def slice_x(self):
        """Slice x.

        Returns:
            float: Horizontal source point where Wigner function is
             calculated [mm].
        """
        return self._slice_x

    @property
    def slice_y(self):
        """Slice y.

        Returns:
            float: Vertical source point where Wigner function is
             calculated [mm].
        """
        return self._slice_y

    @property
    def slice_px(self):
        """Slice x'.

        Returns:
            float: Horizontal source angle where Wigner function is
             calculated [mrad].
        """
        return self._slice_px

    @property
    def slice_py(self):
        """Slice y'.

        Returns:
            float: Horizontal source angle where Wigner function is
             calculated [mrad].
        """
        return self._slice_py

    @property
    def output_captions(self):
        """Output captions.

        Returns:
            dict: Captions with spectra output
        """
        return self._output_captions

    @property
    def output_data(self):
        """Output data.

        Returns:
            dict: Data output from spectra
        """
        return self._output_data

    @property
    def output_variables(self):
        """Output variables.

        Returns:
            dict: Variables from spectra
        """
        return self._output_variables

    @property
    def add_phase_errors(self):
        """Add phase error.

        Returns:
            bool: If true user can set phase errors.
        """
        return self._add_phase_errors

    @property
    def flux(self):
        """Flux output.

        Returns:
            numpy array: Flux [ph/s/mr²/0.1%B.W].
        """
        return self._flux

    @property
    def power_density(self):
        return self._power_density

    @property
    def brilliance(self):
        """Brilliance output.

        Returns:
            numpy array: Brilliance [ph/s/mr²/0.1%B.W/mm²].
        """
        return self._brilliance

    @property
    def pl(self):
        """Linear polarization.

        Returns:
            numpy array: Linear polarization s1/s0
        """
        return self._pl

    @property
    def pc(self):
        """Circular polarization.

        Returns:
            numpy array: Circular polarization s3/s0
        """
        return self._pc

    @property
    def pl45(self):
        """Linear polarization 45°.

        Returns:
            numpy array: Linear polarization 45° s2/s0
        """
        return self._pl45

    @property
    def energies(self):
        """Energies.

        Returns:
            numpy array: Energyes [eV]
        """
        return self._energies

    @property
    def x(self):
        """Horizontal angle.

        Returns:
            numpy array: Horizontal angle [mrad]
        """
        return self._x

    @property
    def y(self):
        """Vertical angle.

        Returns:
            numpy array: Vertical angle [mrad]
        """
        return self._y

    @property
    def k(self):
        """Deflection parameter K.

        Returns:
            numpy array: Deflecetion parameter K.
        """
        return self._k

    @property
    def output_kx(self):
        """Deflection parameter Kx.

        Returns:
            numpy array: Deflecetion parameter Kx.
        """
        return self._kx

    @property
    def output_ky(self):
        """Deflection parameter Ky.

        Returns:
            numpy array: Deflecetion parameter Ky.
        """
        return self._ky

    @method.setter
    def method(self, value):
        self._method = value

    @indep_var.setter
    def indep_var(self, value):
        self._indep_var = value
        if value == self.CalcConfigs.Variable.energy:
            self._slit_position = [0, 0]
        elif value == self.CalcConfigs.Variable.mesh_xy:
            self._slit_position = None
            self._slit_shape = self.CalcConfigs.SlitShape.none

    @output_type.setter
    def output_type(self, value):
        self._output_type = value
        if value == self.CalcConfigs.Output.flux_density:
            self._slit_shape = self.CalcConfigs.SlitShape.none

    @energy_range.setter
    def energy_range(self, value):
        if self.indep_var != self.CalcConfigs.Variable.energy:
            raise ValueError(
                "Energy range can only be defined if the independent variable is energy."  # noqa: E501
            )
        else:
            self._energy_range = value

    @energy_step.setter
    def energy_step(self, value):
        if self.indep_var != self.CalcConfigs.Variable.energy:
            raise ValueError(
                "Energy step can only be defined if the independent variable is energy."  # noqa: E501
            )
        else:
            self._energy_step = value

    @observation_angle.setter
    def observation_angle(self, value):
        if self.indep_var != self.CalcConfigs.Variable.energy:
            raise ValueError(
                "Observation position can only be defined if the independent variable is energy."  # noqa: E501
            )
        else:
            self._slit_position = value

    @slit_acceptance.setter
    def slit_acceptance(self, value):
        if self.output_type != self.CalcConfigs.Output.flux:
            if self.source_type == self.SourceType.bending_magnet:
                self._slit_acceptance = value
            else:
                raise ValueError(
                    "Slit acceptance can only be defined if the output type is flux."  # noqa: E501
                )
        else:
            self._slit_acceptance = value

    @slit_shape.setter
    def slit_shape(self, value):
        if self.output_type != self.CalcConfigs.Output.flux:
            raise ValueError(
                "Slit shape can only be defined if the output type is flux."  # noqa: E501
            )
        else:
            self._slit_shape = value

    @target_energy.setter
    def target_energy(self, value):
        if self.indep_var != self.CalcConfigs.Variable.mesh_xy:
            raise ValueError(
                "Target energy can only be defined if the variable is a xy mesh."  # noqa: E501
            )
        else:
            self._target_energy = value

    @x_range.setter
    def x_range(self, value):
        if self.indep_var != self.CalcConfigs.Variable.mesh_xy:
            raise ValueError(
                "X range can only be defined if the variable is a xy mesh."  # noqa: E501
            )
        else:
            self._x_range = value

    @y_range.setter
    def y_range(self, value):
        if self.indep_var != self.CalcConfigs.Variable.mesh_xy:
            raise ValueError(
                "Y range can only be defined if the variable is a xy mesh."  # noqa: E501
            )
        else:
            self._y_range = value

    @x_nr_pts.setter
    def x_nr_pts(self, value):
        if self.indep_var != self.CalcConfigs.Variable.mesh_xy:
            raise ValueError(
                "X range can only be defined if the variable is a xy mesh."  # noqa: E501
            )
        else:
            self._x_nr_pts = value

    @y_nr_pts.setter
    def y_nr_pts(self, value):
        if self.indep_var != self.CalcConfigs.Variable.mesh_xy:
            raise ValueError(
                "Y range can only be defined if the variable is a xy mesh."  # noqa: E501
            )
        else:
            self._y_nr_pts = value

    @harmonic_range.setter
    def harmonic_range(self, value):
        if self.indep_var != self.CalcConfigs.Variable.k:
            raise ValueError(
                "Harmonic range can only be defined if the variable is k."
            )
        else:
            self._harmonic_range = value

    @k_range.setter
    def k_range(self, value):
        if self.indep_var != self.CalcConfigs.Variable.k:
            raise ValueError(
                "K range can only be defined if the variable is k."
            )
        else:
            self._k_range = value

    @k_nr_pts.setter
    def k_nr_pts(self, value):
        if self.indep_var != self.CalcConfigs.Variable.k:
            raise ValueError(
                "K nr points can only be defined if the variable is k."
            )
        else:
            self._k_nr_pts = value

    @slice_x.setter
    def slice_x(self, value):
        if self.indep_var != self.CalcConfigs.Variable.k:
            raise ValueError(
                "Slice x can only be defined if the variable is k."
            )
        else:
            self._slice_x = value

    @slice_y.setter
    def slice_y(self, value):
        if self.indep_var != self.CalcConfigs.Variable.k:
            raise ValueError(
                "Slice y can only be defined if the variable is k."
            )
        else:
            self._slice_y = value

    @slice_px.setter
    def slice_px(self, value):
        if self.indep_var != self.CalcConfigs.Variable.k:
            raise ValueError(
                "Slice x' can only be defined if the variable is k."
            )
        else:
            self._slice_px = value

    @slice_py.setter
    def slice_py(self, value):
        if self.indep_var != self.CalcConfigs.Variable.k:
            raise ValueError(
                "Slice y' can only be defined if the variable is k."
            )
        else:
            self._slice_py = value

    @add_phase_errors.setter
    def add_phase_errors(self, value):
        if type(value) is not bool:
            raise ValueError(
                "Add phase error must be a boolean"  # noqa: E501
            )
        else:
            self._add_phase_errors = value

    def set_config(self):  # noqa: C901
        """Set calc config."""
        config_name = REPOS_PATH + "/calculation_parameters/"
        config_name += self.source_type
        config_name += "_"
        config_name += self.method
        config_name += "_"
        config_name += self.indep_var
        config_name += "_"
        config_name += self.output_type

        if self.slit_shape != "":
            config_name += "_"
            config_name += self.slit_shape

        config_name += ".json"

        file = open(config_name)
        input_temp = json.load(file)

        flag_bend = False

        input_temp = self._set_accelerator_config(
            self._accelerator, input_temp, flag_bend
        )

        if self.source_type == self.SourceType.bending_magnet:
            del input_temp["Accelerator"]["Options"]["Zero Energy Spread"]
            del input_temp["Accelerator"]["Options"]["Injection Condition"]
            flag_bend = True

        if self.field is not None:
            data = _np.zeros((3, len(self.field[:, 0])))
            data[0, :] = self.field[:, 0]
            data[1, :] = self.field[:, 2]
            data[2, :] = self.field[:, 1]
            input_temp["Light Source"]["Field Profile"]["data"] = data.tolist()

        if self.ky is not None:
            if (
                self.source_type == self.SourceType.horizontal_undulator
                or self.source_type == self.SourceType.helical_undulator
                or self.source_type == self.SourceType.wiggler
            ):
                input_temp["Light Source"]["K value"] = self.ky

        if self.kx is not None:
            if self.source_type == self.SourceType.vertical_undulator:
                input_temp["Light Source"]["K value"] = self.kx

        if self.kx is not None and self.ky is not None:
            if (
                self.source_type == self.SourceType.elliptic_undulator
                or self.source_type == self.SourceType.figure8_undulator
                or self.source_type
                == self.SourceType.vertical_figure8_undulator
            ):
                input_temp["Light Source"]["K<sub>x,y</sub>"] = [
                    self.kx,
                    self.ky,
                ]

        if self.by_peak is not None:
            if self.source_type == self.SourceType.bending_magnet:
                input_temp["Light Source"]["B (T)"] = self.by_peak
                energy = self._accelerator.energy
                brho = energy * 1e9 * ECHARGE / (ECHARGE * LSPEED)
                rho = brho / self.by_peak
                input_temp["Light Source"]["&rho; (m)"] = rho

            elif self.source_type == self.SourceType.wiggler:
                input_temp["Light Source"]["B (T)"] = self.by_peak

        if self.rho is not None:
            if self.source_type == self.SourceType.bending_magnet:
                input_temp["Light Source"]["&rho; (m)"] = self.rho
                energy = self._accelerator.energy
                brho = energy * 1e9 * ECHARGE / (ECHARGE * LSPEED)
                by = brho / self.rho
                input_temp["Light Source"]["B (T)"] = by

        if self.period is not None:
            input_temp["Light Source"]["&lambda;<sub>u</sub> (mm)"] = (
                self.period
            )

        if self.length is not None:
            if self.source_type == self.SourceType.bending_magnet:
                input_temp["Light Source"]["BM Length (m)"] = self.length
            else:
                input_temp["Light Source"]["Device Length (m)"] = self.length

        if self.energy_range is not None:
            input_temp["Configurations"]["Energy Range (eV)"] = (
                self.energy_range
            )

        if self.energy_step is not None:
            if (
                self.source_type == self.SourceType.bending_magnet
                or self.source_type == self.SourceType.wiggler
            ):
                nr_points = int(
                    (self.energy_range[1] - self.energy_range[0])
                    / self.energy_step
                )
                input_temp["Configurations"]["Points (Energy)"] = nr_points
            else:
                input_temp["Configurations"]["Energy Pitch (eV)"] = (
                    self.energy_step
                )

        if self.observation_angle is not None:
            if self.output_type == self.CalcConfigs.Output.flux_density:
                input_temp["Configurations"][
                    "Angle &theta;<sub>x,y</sub> (mrad)"
                ] = self.observation_angle
            elif self.output_type == self.CalcConfigs.Output.flux:
                input_temp["Configurations"][
                    "Slit Pos.: &theta;<sub>x,y</sub> (mrad)"
                ] = self.observation_angle

        if self.slit_acceptance is not None:
            if self.slit_shape == self.CalcConfigs.SlitShape.circular:
                input_temp["Configurations"][
                    "Slit &theta;<sub>1,2</sub> (mrad)"
                ] = self.slit_acceptance
            elif self.slit_shape == self.CalcConfigs.SlitShape.rectangular:
                input_temp["Configurations"][
                    "&Delta;&theta;<sub>x,y</sub> (mrad)"
                ] = self.slit_acceptance
            if self.source_type == self.SourceType.bending_magnet:
                if self.output_type == self.CalcConfigs.Output.flux_density:
                    input_temp["Configurations"]["X' Acceptance (mrad)"] = (
                        self.slit_acceptance
                    )

        if self.target_energy is not None:
            input_temp["Configurations"]["Target Energy (eV)"] = (
                self.target_energy
            )

        if self.x_range is not None:
            input_temp["Configurations"][
                "&theta;<sub>x</sub> Range (mrad)"
            ] = self.x_range
            input_temp["Configurations"][
                "&theta;<sub>y</sub> Range (mrad)"
            ] = self.y_range
            input_temp["Configurations"]["Points (x)"] = self.x_nr_pts
            input_temp["Configurations"]["Points (y)"] = self.y_nr_pts

        if self.harmonic_range is not None:
            input_temp["Configurations"]["Harmonic Range"] = (
                self.harmonic_range
            )
            if (
                self.source_type == self.SourceType.horizontal_undulator
                or self.source_type == self.SourceType.vertical_undulator
                or self.source_type == self.SourceType.helical_undulator
            ):
                input_temp["Configurations"]["K Range"] = self.k_range
            else:
                input_temp["Configurations"]["K<sub>&perp;</sub> Range"] = (
                    self.k_range
                )
            if self.method == self.CalcConfigs.Method.wigner:
                input_temp["Configurations"]["Slice X (mm)"] = self.slice_x
                input_temp["Configurations"]["Slice Y (mm)"] = self.slice_y
                input_temp["Configurations"]["Slice X' (mrad)"] = self.slice_px
                input_temp["Configurations"]["Slice Y' (mrad)"] = self.slice_py
            input_temp["Configurations"]["Points (K)"] = self.k_nr_pts

        input_temp["Configurations"]["Distance from the Source (m)"] = (
            self.distance_from_source
        )

        self._input_template = input_temp

    def verify_valid_parameters(self):  # noqa: C901
        """Check if calculation parameters are valid.

        Returns:
            bool: Returns True of False.
        """
        if self.indep_var == self.CalcConfigs.Variable.energy:
            if self.energy_range is None:
                raise ValueError("Energy range must be defined.")

            if self.energy_step is None:
                raise ValueError("Energy step must be defined.")

            if self.observation_angle is None:
                raise ValueError("Observation angle must be defined.")

            if self.source_type == self.SourceType.bending_magnet:
                if self.slit_acceptance is None:
                    raise ValueError("Slit acceptance must be defined.")

            if self.output_type == self.CalcConfigs.Output.flux:
                if self.slit_acceptance is None:
                    raise ValueError("Slit acceptance must be defined.")

                if self.slit_shape is None:
                    raise ValueError("Slit shape must be defined.")

        if self.indep_var == self.CalcConfigs.Variable.mesh_xy:
            if (
                self.target_energy is None
                and self.output_type == self.CalcConfigs.Output.flux_density
            ):
                raise ValueError("Energy target must be defined")

            if self.x_range is None:
                raise ValueError("X range must be defined.")

            if self.y_range is None:
                raise ValueError("Y range must be defined.")

            if self.x_nr_pts is None:
                raise ValueError("Nr. of x points must be defined.")

            if self.y_nr_pts is None:
                raise ValueError("Nr. of y points must be defined.")

        if self.indep_var == self.CalcConfigs.Variable.k:
            if self.harmonic_range is None:
                raise ValueError("Harmonic range must be defined.")

            if self.k_range is None:
                raise ValueError("K range must be defined.")

            if self.k_nr_pts is None:
                raise ValueError("Number of K points must be defined.")

            if self.method == self.CalcConfigs.Method.wigner:
                if self.slice_x is None:
                    raise ValueError("Slice x must be defined.")

                if self.slice_y is None:
                    raise ValueError("Slice y must be defined.")

                if self.slice_px is None:
                    raise ValueError("Slice px must be defined.")

                if self.slice_py is None:
                    raise ValueError("Slice py must be defined.")

        return True

    def run_calculation(self, time_print: bool = False):
        """Run calculation."""
        self.verify_valid_parameters()
        solver = self._run_solver(self._input_template, time_print)
        self._solver = solver
        captions, data, variables = self.extractdata(solver)
        self._output_captions = captions
        self._output_data = data
        self._output_variables = variables
        self._set_outputs()

    def _set_outputs(self):
        data = self._output_data
        captions = self._output_captions
        variables = self._output_variables

        if self.indep_var == self.CalcConfigs.Variable.energy:
            self._flux = data[0, :]
            if len(captions["titles"]) == 5:
                self._pl = data[1, :]
                self._pc = data[2, :]
                self._pl45 = data[3, :]
            elif len(captions["titles"]) == 6:
                self._brilliance = data[1, :]
                self._pl = data[2, :]
                self._pc = data[3, :]
                self._pl45 = data[4, :]
            self._energies = self._output_variables[0, :]

        elif self.indep_var == self.CalcConfigs.Variable.mesh_xy:
            if self.output_type == self.CalcConfigs.Output.power_density:
                self._power_density = data[0, :]
                self._x = _np.array(self._output_variables[0][:])
                self._y = _np.array(self._output_variables[1][:])
                self._power_density = _np.reshape(
                    self._power_density, (len(self._x), len(self._y))
                )
                self._power_density = _np.flip(self._power_density, axis=0)

            if self.output_type == self.CalcConfigs.Output.flux_density:
                self._flux = data[0, :]
                self._x = _np.array(self._output_variables[0][:])
                self._y = _np.array(self._output_variables[1][:])
                self._flux = _np.reshape(
                    self._flux, (len(self._x), len(self._y))
                )
                self._flux = _np.flip(self._flux, axis=0)
                self._pl = data[1, :]
                self._pc = data[2, :]
                self._pl45 = data[3, :]

                self._pl = _np.reshape(self._pl, (len(self._x), len(self._y)))
                self._pl = _np.flip(self._pl, axis=0)

                self._pc = _np.reshape(self._pc, (len(self._x), len(self._y)))
                self._pc = _np.flip(self._pc, axis=0)

                self._pl45 = _np.reshape(
                    self._pl45, (len(self._x), len(self._y))
                )
                self._pl45 = _np.flip(self._pl45, axis=0)

        elif self.indep_var == self.CalcConfigs.Variable.k:
            if self.method == self.CalcConfigs.Method.wigner:
                if (
                    self.source_type != self.SourceType.elliptic_undulator
                    and self.source_type != self.SourceType.figure8_undulator
                    and self.source_type
                    != self.SourceType.vertical_figure8_undulator
                ):
                    self._k = data[:, 0, :]
                    self._brilliance = data[:, 1, :]
                    self._energies = variables[:, :]
                    if self.add_phase_errors is True:
                        self._brilliance = self.apply_phase_errors(
                            self._brilliance, self._use_recovery_params
                        )

                else:
                    self._kx = data[:, 0, :]
                    self._ky = data[:, 1, :]
                    self._brilliance = data[:, 2, :]
                    self._energies = variables[:, :]
            elif self.method == self.CalcConfigs.Method.far_field:
                if (
                    self.source_type != self.SourceType.elliptic_undulator
                    and self.source_type != self.SourceType.figure8_undulator
                    and self.source_type
                    != self.SourceType.vertical_figure8_undulator
                ):
                    self._k = data[:, 1, :]
                    self._flux = data[:, 2, :]
                    self._energies = variables[:, :]
                    if self.add_phase_errors is True:
                        self._flux = self.apply_phase_errors(
                            self._flux, self._use_recovery_params
                        )
                else:
                    self._kx = data[:, 1, :]
                    self._ky = data[:, 2, :]
                    self._flux = data[:, 3, :]
                    self._energies = variables[:, :]

    def extractdata(self, solver):
        """Extract solver data.

        Args:
            solver (spectra solver): Spectra solver object

        Returns:
            dict: captions
            dict: data
            dict: variables
        """
        captions = solver.GetCaptions()
        data = _np.array(solver.GetData()["data"])
        if self.indep_var != self.CalcConfigs.Variable.k:
            variables = _np.array(solver.GetData()["variables"], dtype=object)
        else:
            if (
                self.source_type == self.SourceType.figure8_undulator
                or self.source_type
                == self.SourceType.vertical_figure8_undulator
            ):
                nr_harmonics = (
                    int((self.harmonic_range[-1] - self.harmonic_range[0]) * 2)
                    + 1
                )
                if self.method == self.CalcConfigs.Method.wigner:
                    data = _np.zeros((nr_harmonics, 3, self.k_nr_pts))
                else:
                    data = _np.zeros((nr_harmonics, 7, self.k_nr_pts))
            else:
                nr_harmonics = (
                    int((self.harmonic_range[-1] - self.harmonic_range[0]) / 2)
                    + 1
                )
                if self.source_type == self.SourceType.elliptic_undulator:
                    if self.method == self.CalcConfigs.Method.wigner:
                        data = _np.zeros((nr_harmonics, 3, self.k_nr_pts))
                    else:
                        data = _np.zeros((nr_harmonics, 7, self.k_nr_pts))
                else:
                    if self.method == self.CalcConfigs.Method.wigner:
                        data = _np.zeros((nr_harmonics, 2, self.k_nr_pts))
                    else:
                        data = _np.zeros((nr_harmonics, 6, self.k_nr_pts))
            variables = _np.zeros((nr_harmonics, self.k_nr_pts))
            for i in range(nr_harmonics):
                variables[i, :] = _np.array(
                    solver.GetDetailData(i)["variables"]
                )
                data[i, :, :] = _np.array(solver.GetDetailData(i)["data"])
        return captions, data, variables

    def apply_phase_errors(self, values, rec_param=True):
        """Add phase errors.

        Args:
            values (numpy 2d array): It can be brilliance of flux
            rec_param (bool, optional): Use recovery params. Defaults to True.

        Returns:
            numpy 2d array: brilliance of flux with phase errors
        """
        fname = REPOS_PATH + "/files/phase_errors_fit.txt"
        data = _np.genfromtxt(fname, unpack=True, skip_header=1)
        h = data[:, 0]
        ph_err1 = data[:, 1]
        ph_err2 = data[:, 2]
        harm0 = self.harmonic_range[0]
        harmf = self.harmonic_range[-1]
        idcs = (_np.arange(harm0 - 1, harmf, 2),)
        if rec_param:
            ph = ph_err2[idcs]
        else:
            ph = ph_err1[idcs]
        ph_full = _np.tile(ph, values.shape[1]).reshape(
            values.shape, order="F"
        )
        return values * ph_full

    @staticmethod
    def process_brilliance_curve(
        input_energies, input_brilliance, superp_value=250
    ):
        """Process brilliance curve.

        Args:
            input_energies (numpy 2d array): Array with energies and
             brilliances for each harmonic
            input_brilliance (numpy 2d array): Array with energies and
                brilliances for each harmonic
            superp_value (int, optional): Desired value of energy
             superposition. Defaults to 250.

        Returns:
            _type_: _description_
        """
        flag_pre_processing = False
        harm_nr = input_energies.shape[0]
        energies = _np.zeros((harm_nr, 2001))
        brilliance = _np.zeros((harm_nr, 2001))
        for i in _np.arange(harm_nr - 1):
            if flag_pre_processing is False:
                e_harm = input_energies[i, :]
                b_harm = input_brilliance[i, :]
                idx = _np.argsort(e_harm)
                e_harm = e_harm[idx]
                b_harm = b_harm[idx]
                e_harm_interp = _np.linspace(
                    _np.min(e_harm), _np.max(e_harm), 2001
                )
                b_harm_interp = _np.exp(
                    _np.interp(e_harm_interp, e_harm, _np.log(b_harm))
                )
            else:
                e_harm_interp = energies[i, :]
                b_harm_interp = brilliance[i, :]

            e_next_harm = input_energies[i + 1, :]
            b_next_harm = input_brilliance[i + 1, :]
            idx = _np.argsort(e_next_harm)
            e_next_harm = e_next_harm[idx]
            b_next_harm = b_next_harm[idx]

            e_next_harm_interp = _np.linspace(
                _np.min(e_next_harm), _np.max(e_next_harm), 2001
            )
            b_next_harm_interp = _np.exp(
                _np.interp(
                    e_next_harm_interp, e_next_harm, _np.log(b_next_harm)
                )
            )

            max_e_harm = _np.nanmax(e_harm_interp)
            min_e_harm = _np.nanmin(e_harm_interp)
            max_e_next_harm = _np.nanmax(e_next_harm_interp)
            min_e_next_harm = _np.nanmin(e_next_harm_interp)

            flag_pre_processing = False
            if max_e_harm >= min_e_next_harm:
                flag_pre_processing = True

                min_abs = _np.max((min_e_harm, min_e_next_harm))
                max_abs = _np.min((max_e_harm, max_e_next_harm))
                energy_intersect = _np.linspace(min_abs, max_abs, 2001)

                b_harm_intersect = _np.interp(
                    energy_intersect, e_harm_interp, b_harm_interp
                )
                b_next_harm_intersect = _np.interp(
                    energy_intersect, e_next_harm_interp, b_next_harm_interp
                )

                idcs_bigger = _np.where(
                    b_next_harm_intersect >= b_harm_intersect
                )

                ecross = energy_intersect[_np.min(idcs_bigger)]

                idx_cut_e1 = _np.nanargmin(
                    _np.abs(e_harm_interp - ecross - superp_value)
                )
                idx_cut_e3 = _np.nanargmin(
                    _np.abs(e_next_harm_interp - ecross + superp_value)
                )

                e_harm = e_harm_interp[:idx_cut_e1]
                b_harm = b_harm_interp[:idx_cut_e1]

                e_next_harm = e_next_harm_interp[idx_cut_e3:]
                b_next_harm = b_next_harm_interp[idx_cut_e3:]

            e_harm_new = _np.copy(e_harm)
            b_harm_new = _np.copy(b_harm)
            e_harm_new.resize(2001)
            b_harm_new.resize(2001)
            idx = len(e_harm) - 1
            e_harm_new[idx:] = _np.full(len(e_harm_new[idx:]), _np.nan)
            b_harm_new[idx:] = _np.full(len(e_harm_new[idx:]), _np.nan)

            e_next_harm_new = _np.copy(e_next_harm)
            b_next_harm_new = _np.copy(b_next_harm)
            e_next_harm_new.resize(2001)
            b_next_harm_new.resize(2001)
            idx = len(e_next_harm) - 1
            e_next_harm_new[idx:] = _np.full(
                len(e_next_harm_new[idx:]), _np.nan
            )
            b_next_harm_new[idx:] = _np.full(
                len(e_next_harm_new[idx:]), _np.nan
            )

            energies[i, :] = e_harm_new
            brilliance[i, :] = b_harm_new

            energies[i + 1, :] = e_next_harm_new
            brilliance[i + 1, :] = b_next_harm_new

        return energies, brilliance


class SpectraInterface:
    """Spectra Interface class."""

    def __init__(self):
        """Class constructor."""
        self._accelerator = StorageRingParameters()
        self._calc = Calc(self._accelerator)
        self._sources = None
        self._energies = None
        self._brilliances = None
        self._fluxes = None
        self._target_energy = None
        self._flux_matrix = None
        self._info_matrix = None
        self._flag_brill_processed = False
        self._flag_flux_processed = False

    @property
    def accelerator(self):
        """Accelerator parameters.

        Returns:
            StorageRingParameters object: class to config accelerator.
        """
        return self._accelerator

    @property
    def calc(self):
        """CalcFlux object.

        Returns:
            CalcFlux object: Class to calculate flux
        """
        return self._calc

    @property
    def sources(self):
        """Sources list.

        Returns:
            List: List of sources objects
        """
        return self._sources

    @property
    def energies(self):
        """List of energies for each undulator.

        Returns:
            list of numpy arrays: Energies for each undulator, for each
             harmonic.
        """
        return self._energies

    @property
    def brilliances(self):
        """List of brilliances for each undulator.

        Returns:
            list of numpy arrays: Brilliances for each undulator, for each
             harmonic.
        """
        return self._brilliances

    @property
    def fluxes(self):
        """List of fluxes for each undulator.

        Returns:
            list of numpy arrays: Fluxes for each undulator, for each
             harmonic.
        """
        return self._fluxes

    @property
    def target_energy(self):
        """Target energy.

        Returns:
            float: Target energy to analyse.
        """
        return self._target_energy

    @property
    def flux_matrix(self):
        """Flux matrix.

        Returns:
            Array: Flux matrix to analyse.
        """
        return self._flux_matrix

    @property
    def info_matrix(self):
        """Information about the respective undulators in the flux matrix.

        Returns:
            Array: Undulators information to analyse.
        """
        return self._info_matrix

    @sources.setter
    def sources(self, value):
        self._sources = value

    @target_energy.setter
    def target_energy(self, value):
        self._target_energy = value

    def calc_brilliance_curve(
        self,
        harmonic_range=[1, 5],
        nr_pts_k=15,
        kmin=0.2,
        emax=20e3,
        x_accep=1,
        beta_sections=None,
    ):
        """Calc brilliance curve.

        Args:
            harmonic_range (list, optional): List of desired harmonics.
             Defaults to [1, 5].
            nr_pts_k (int, optional): Number of k points. Defaults to 15.
            kmin (float): Minimum k value. Defaults to 0.2
            emax (float): Max value of energy for dipoles and wigglers.
            x_accep (float): X acceptance for bending magnet radiation.
            beta_sections (list of string): List of beta sections for each
             source.

        """
        self._flag_brill_processed = False
        self.calc._slit_shape = ""
        source_list = self.sources
        energies = list()
        brilliances = list()
        flag_bend = False
        for i, source in enumerate(source_list):
            print(
                "Calculating curve for source {:.0f}/{:.0f}".format(
                    i + 1, len(source_list)
                )
            )
            if source.source_type != "bendingmagnet":
                if source.gap == 0:
                    kmax = source.calc_max_k(self.accelerator)
                else:
                    kmax = source.get_k()

                if source.source_type == "wiggler":
                    flag_bend = True
                    b_max = source.undulator_k_to_b(kmax, source.period)
                    self.calc.source_type = self.calc.SourceType.wiggler
                    self.calc.method = self.calc.CalcConfigs.Method.far_field
                    self.calc.indep_var = self.calc.CalcConfigs.Variable.energy
                    self.calc.output_type = (
                        self.calc.CalcConfigs.Output.flux_density
                    )
                    self.calc.period = source.period
                    self.calc.by_peak = b_max
                    self.calc.ky = kmax
                    self.calc.observation_angle = [0, 0]
                    self.calc.energy_range = [1, emax]
                    self.calc.energy_step = 50
                else:
                    self.calc.output_type = (
                        self.calc.CalcConfigs.Output.brilliance
                    )
                    self.calc.add_phase_errors = source.add_phase_errors
                    self.calc._use_recovery_params = source.use_recovery_params
                    self.calc.indep_var = self.calc.CalcConfigs.Variable.k
                    self.calc.method = self.calc.CalcConfigs.Method.wigner
                    self.calc.slice_x = 0
                    self.calc.slice_px = 0
                    self.calc.slice_y = 0
                    self.calc.slice_py = 0
                    self.calc.harmonic_range = harmonic_range
                    self.calc.k_nr_pts = nr_pts_k

                    polarization = source.polarization
                    if polarization == "hp":
                        self.calc.source_type = (
                            self.calc.SourceType.horizontal_undulator
                        )
                        self.calc.by_peak = 1
                    elif polarization == "vp":
                        self.calc.source_type = (
                            self.calc.SourceType.vertical_undulator
                        )
                        self.calc.bx_peak = 1
                    elif polarization == "cp":
                        self.calc.source_type = (
                            self.calc.SourceType.elliptic_undulator
                        )
                        self.calc.bx_peak = 1
                        self.calc.by_peak = source.fields_ratio
                    else:
                        return

                    self.calc.k_range = [kmin, kmax]
                    self.calc.period = source.period

            else:
                flag_bend = True
                b = source.b_peak
                self.calc.source_type = self.calc.SourceType.bending_magnet
                self.calc.method = self.calc.CalcConfigs.Method.far_field
                self.calc.indep_var = self.calc.CalcConfigs.Variable.energy
                self.calc.slit_acceptance = x_accep
                self.calc.output_type = (
                    self.calc.CalcConfigs.Output.flux_density
                )
                self.calc.by_peak = b
                self.calc.observation_angle = [0, 0]
                self.calc.energy_range = [1, emax]
                self.calc.energy_step = 50

            self.calc.length = source.source_length

            if beta_sections is not None:
                if beta_sections[i] == "high":
                    self.accelerator.set_high_beta_section()
                elif beta_sections[i] == "low":
                    self.accelerator.set_low_beta_section()
                elif beta_sections[i] == "b2":
                    self.accelerator.set_b2_section()
                elif beta_sections[i] == "bc":
                    self.accelerator.set_bc_section()
                elif beta_sections[i] == "b1":
                    self.accelerator.set_b1_section()
                else:
                    raise ValueError("Invalid beta section.")

            self.calc.set_config()
            self.calc.run_calculation()

            energies.append(self.calc.energies)
            brilliances.append(self.calc.brilliance)

        if flag_bend:
            energies = _np.array(energies, dtype=object)
            brilliances = _np.array(brilliances, dtype=object)
        else:
            energies = _np.array(energies)
            brilliances = _np.array(brilliances)
        self._energies = energies
        self._brilliances = brilliances

    def calc_flux_curve(
        self,
        energy_range=[1, 5],
        harmonic_range=[1, 5],
        nr_pts_k=15,
        kmin=0.2,
        slit_shape="circslit",
        slit_acceptances=[[0, 0.04]],
        beta_sections=None,
    ):
        """Calc flux curves.

        Args:
            energy_range (list, optional): Energy range for wigglers and
             bending magnets. Defaults to [1, 5].
            harmonic_range (list, optional): List of desired harmonics.
             Defaults to [1, 5].
            nr_pts_k (int, optional): Number of k points. Defaults to 15.
            kmin (float): Minimum k value. Defaults to 0.2
            slit_shape (str, optional): Circular or rectangular.
             Defaults to "circslit".
            slit_acceptance (list, optional): Slit acceptance.
             Defaults to [0, 0.04].
            beta_sections (list of string): List of beta sections for each
             source.

        Raises:
            ValueError: _description_
        """
        self._flag_flux_processed = False
        source_list = self.sources
        energies = list()
        fluxes = list()
        slit_acceptances = _np.array(slit_acceptances)
        if slit_acceptances.shape[0] == 1:
            slit_acceptances = _np.full(
                (len(source_list), 2), slit_acceptances[0]
            )
        slit_acceptances = slit_acceptances.tolist()
        flag_bend = False
        for i, source in enumerate(source_list):
            print(
                "Calculating curve for source {:.0f}/{:.0f}".format(
                    i + 1, len(source_list)
                )
            )
            if source.source_type != "bendingmagnet":
                if source.gap == 0:
                    kmax = source.calc_max_k(self.accelerator)
                else:
                    kmax = source.get_k()
                if source.source_type == "wiggler":
                    flag_bend = True
                    b_max = source.undulator_k_to_b(kmax, source.period)
                    self.calc.source_type = self.calc.SourceType.wiggler
                    self.calc.method = self.calc.CalcConfigs.Method.far_field
                    self.calc.indep_var = self.calc.CalcConfigs.Variable.energy
                    self.calc.output_type = self.calc.CalcConfigs.Output.flux
                    self.calc.slit_shape = slit_shape
                    self.calc.period = source.period
                    self.calc.by_peak = b_max
                    self.calc.ky = kmax
                    self.calc.observation_angle = [0, 0]
                    self.calc.slit_acceptance = slit_acceptances[i]
                    self.calc.energy_range = energy_range
                    self.calc.energy_step = 1
                else:
                    self.calc.add_phase_errors = source.add_phase_errors
                    self.calc._use_recovery_params = source.use_recovery_params
                    self.calc.output_type = self.calc.CalcConfigs.Output.flux
                    self.calc.indep_var = self.calc.CalcConfigs.Variable.k
                    self.calc.method = self.calc.CalcConfigs.Method.far_field
                    self.calc.slit_shape = slit_shape
                    self.calc.harmonic_range = harmonic_range
                    self.calc.k_nr_pts = nr_pts_k
                    self.calc.slit_acceptance = slit_acceptances[i]

                    polarization = source.polarization
                    if polarization == "hp":
                        self.calc.source_type = (
                            self.calc.SourceType.horizontal_undulator
                        )
                        self.calc.by_peak = 1
                    elif polarization == "vp":
                        self.calc.source_type = (
                            self.calc.SourceType.vertical_undulator
                        )
                        self.calc.bx_peak = 1
                    elif polarization == "cp":
                        self.calc.source_type = (
                            self.calc.SourceType.elliptic_undulator
                        )
                        self.calc.bx_peak = 1
                        self.calc.by_peak = source.fields_ratio
                    else:
                        return

                    self.calc.k_range = [kmin, kmax]
                    self.calc.period = source.period

            else:
                flag_bend = True
                b = source.b_peak
                self.calc.source_type = self.calc.SourceType.bending_magnet
                self.calc.method = self.calc.CalcConfigs.Method.far_field
                self.calc.indep_var = self.calc.CalcConfigs.Variable.energy
                self.calc.output_type = self.calc.CalcConfigs.Output.flux
                self.calc.slit_shape = slit_shape
                self.calc.observation_angle = [0, 0]
                self.calc.slit_acceptance = slit_acceptances[i]
                self.calc.energy_range = energy_range
                self.calc.energy_step = 1
                self.calc.by_peak = b

            self.calc.length = source.source_length

            if beta_sections is not None:
                if beta_sections[i] == "high":
                    self.accelerator.set_high_beta_section()
                elif beta_sections[i] == "low":
                    self.accelerator.set_low_beta_section()
                elif beta_sections[i] == "b2":
                    self.accelerator.set_b2_section()
                elif beta_sections[i] == "bc":
                    self.accelerator.set_bc_section()
                elif beta_sections[i] == "b1":
                    self.accelerator.set_b1_section()
                else:
                    raise ValueError("Invalid beta section.")

            self.calc.set_config()
            self.calc.run_calculation()

            energies.append(self.calc.energies)
            fluxes.append(self.calc.flux)

        if flag_bend:
            energies = _np.array(energies, dtype=object)
            fluxes = _np.array(fluxes, dtype=object)
        else:
            energies = _np.array(energies)
            fluxes = _np.array(fluxes)

        self._energies = energies
        self._fluxes = fluxes
    
    def calc_k_target(
        self,
        n:int,
        period:float,
        target_energy:float
    ):
        """Calc k for target energy given harmonic number and period.

        Args:
            n (int): harmonic number.
            period (float): undulator period [mm].
            target_energy (float): target energy of radiation [eV].

        Returns:
            float: K value
        """
        gamma = self.accelerator.gamma
        arg = 2*n*gamma**2*PLANCK*2*_np.pi*LSPEED/(target_energy*ECHARGE*1e-3*period)-1
        return _np.sqrt(2)*_np.sqrt(arg)
    
    def _calc_flux(
        self,
        target_energy:float,
        source_period:float,
        source_length:float,
        target_k:float
    ):
        """Calculate flux for one k value.

        Args:
            target_energy (float): target energy of radiation [eV].
            source_period (float): undulator period [mm].
            source_length (float): undulator length [m].
            target_k (float): K value.

        Returns:
            _type_: _description_
        """
        self._target_energy = target_energy
        und: Undulator = self._und
        
        ## Spectra Initialization
        spectra = SpectraInterface()
        spectra.accelerator.set_bsc_with_ivu18()
        if self.accelerator.beta_section == 'low':
            spectra.accelerator.set_low_beta_section()
        else:
            spectra.accelerator.set_high_beta_section()
        
        ## Spectra Configuration
        spectra.accelerator.zero_emittance = self.accelerator.zero_emittance
        spectra.accelerator.zero_energy_spread = self.accelerator.zero_emittance
        
        if und.polarization == "hp":
            spectra.calc.source_type = spectra.calc.SourceType.horizontal_undulator
            spectra.calc.ky = target_k
        elif und.polarization == "vp":
            spectra.calc.source_type = spectra.calc.SourceType.vertical_undulator
            spectra.calc.kx = target_k
        else:
            spectra.calc.source_type = spectra.calc.SourceType.elliptic_undulator
            spectra.calc.kx = target_k / _np.sqrt(1 + und.fields_ratio**2)
            spectra.calc.ky = spectra.calc.kx * und.fields_ratio
        
        spectra.calc.method = spectra.calc.CalcConfigs.Method.far_field
        spectra.calc.output_type = self.calc.output_type

        spectra.calc.distance_from_source = 1
        spectra.calc.observation_angle = [0, 0]
        spectra.calc.energy_range = [self._target_energy, self._target_energy + 0.01]
        spectra.calc.energy_step = 0.01
        
        ## Spectra calculation
        spectra.calc.period = source_period
        spectra.calc.length = source_length
        spectra.calc.set_config()
        spectra.calc.run_calculation()
        
        return [_np.max(spectra.calc.flux), target_k]

    def _parallel_calc_flux(self, args):
        target_k, period, length, _ = args
        return self._calc_flux(self._target_energy, period, length, target_k)

    def calc_flux_matrix(
        self,
        target_energy:float,
        und,
        period_range:tuple=(18,30),
        nr_pts_period:int=20,
        length_range:tuple=(1,3),
        nr_pts_length:int=20,
        n_harmonic_truc:int=15,
    ):
        """Calc flux matrix.

        Args:
            target_energy (float): Target energy [eV]
            und (Undulator object): Must be an object from undulator class.
            nr_pts_period (int, optional): Number of period points.
                Defaults to 20.
            nr_pts_length (int, optional): Number of length points.
                Defaults to 20.
            n_harmonic_truc (int, optional): Harmonic number to truncate
                the calculation. Defaults to 15.

        Returns:
            numpy array: Flux matrix.
            numpy array: Undulators information.
        """
        gamma = self.accelerator.gamma
        self._target_energy = target_energy
        self._und = und
        periods = _np.linspace(period_range[0], period_range[1], nr_pts_period)
        lengths = _np.linspace(length_range[0], length_range[1], nr_pts_length)

        # Arglist assembly
        arglist = []
        for length in lengths:
            for period in periods:
                self._und.period = period
                self._und.source_length = length

                k_max = und.calc_max_k(self.accelerator)

                n = 1
                while (
                    self._und.get_harmonic_energy(
                        n, gamma, 0, self._und.period, k_max
                    )
                    < self._target_energy
                ):
                    n += 1
                if n > 1:
                    n -= 1

                n_truc = n_harmonic_truc

                if n > n_truc:
                    n = n_truc

                ns = _np.linspace(1, n, int(n))

                target_ks = self.calc_k_target(
                    ns, self._und.period, self._target_energy
                )

                idx = _np.isnan(target_ks)
                idx = _np.where(idx == True)

                target_ks = _np.delete(target_ks, idx)
                ns = _np.delete(ns, idx)
                for i, target_k in enumerate(target_ks):
                    arglist += [(target_k, period, length, ns[i])]

        # Parallel calculations
        num_processes = multiprocessing.cpu_count()
        data = []
        with multiprocessing.Pool(processes=num_processes) as parallel:
            data = parallel.map(self._parallel_calc_flux, arglist)

        arglist = _np.array(arglist)
        result = _np.array(data)

        # Identification of breaks with equal length and equal periods
        idx_broke = list(
            _np.where(
                (arglist[:-1, 1] != arglist[1:, 1])
                | (arglist[:-1, 2] != arglist[1:, 2])
            )[0]
        )
        idx_broke.append(len(arglist) - 1)

        i_start = 0
        filter_arglist = []
        filter_result = []

        for i in idx_broke:
            collection_arg = []
            collection_result = []
            for j in range(i_start, i + 1):
                collection_arg.append(list(arglist[j]))
                collection_result.append(list(result[j]))
            i_start = i + 1
            filter_arglist.append(collection_arg)
            filter_result.append(collection_result)

        # Selection of the best results for a given period and length
        best_result = []
        info_unds = []

        for i, fluxs in enumerate(filter_result):
            arr = _np.array(fluxs)[:, 0]
            best_result.append(fluxs[_np.argmax(arr)])
            info_unds.append(filter_arglist[i][_np.argmax(arr)])

        best_result = _np.array(best_result)
        info_unds = _np.array(info_unds)

        # Flux Matrix Reassembly
        flux_matrix = best_result[:, 0]
        flux_matrix = flux_matrix.reshape(
            len(periods), len(lengths), order="F"
        )
        flux_matrix = flux_matrix.transpose()

        self._flux_matrix = flux_matrix
        self._info_matrix = info_unds

        return flux_matrix, info_unds

    def _calc_brilliance(
        self,
        target_harmonic:float,
        source_period:float,
        source_length:float,
        target_k:float
    ):
        """Calculate brilliance for one k value.

        Args:
            target_harmonic (float): target harmonic number of radiation energy [eV].
            source_period (float): undulator period [mm].
            source_length (float): undulator length [m].
            target_k (float): K value.

        Returns:
            _type_: _description_
        """
        und: Undulator = self._und
        
        ## Spectra Configuration
        self.calc.output_type = self.calc.CalcConfigs.Output.brilliance
        self.calc.method = self.calc.CalcConfigs.Method.wigner
        self.calc.indep_var = self.calc.CalcConfigs.Variable.k
        
        if und.polarization == "hp":
            self.calc.source_type = self.calc.SourceType.horizontal_undulator
            self.calc.ky = target_k
        elif und.polarization == "vp":
            self.calc.source_type = self.calc.SourceType.vertical_undulator
            self.calc.kx = target_k
        else:
            self.calc.source_type = self.calc.SourceType.elliptic_undulator
            self.calc.kx = target_k / _np.sqrt(1 + und.fields_ratio**2)
            self.calc.ky = self.calc.kx * und.fields_ratio
        
        self.calc.harmonic_range = [target_harmonic, target_harmonic]
        self.calc.k_range = [0, target_k]
        self.calc.k_nr_pts = 2
        
        self.calc.slice_x = 0
        self.calc.slice_px = 0
        self.calc.slice_y = 0
        self.calc.slice_py = 0
        
        ## Spectra calculation
        self.calc.period = source_period
        self.calc.length = source_length
        
        self.calc.set_config()
        self.calc.run_calculation()
        
        return _np.max(self.calc.brilliance)
    
    def plot_brilliance_curve(
        self,
        process_curves=True,
        superp_value=250,
        title="Brilliance curves",
        xscale="linear",
        yscale="log",
        xlim=[],
        ylim=[],
        linewidth=3,
        savefig=False,
        figsize=(4.5, 3.0),
        figname="brill.png",
        dpi=300,
        legend_fs=10,
        legend_properties=True,
    ):
        """Plot brilliance curves.

        Args:
            process_curves (bool, optional): If true energy superposition will
             be processed. Defaults to True.
            superp_value (int, optional): Desired value of energy
             superposition. Defaults to 250.
            title (str, optional): Plot title.
            xscale (str, optional): xscale axis
             xscale. Defalts to 'linear'.
            yscale (str, optional): yscale axis
             yscale. Defalts to 'log'.
        """
        if self._flag_brill_processed:
            process_curves = False
        energies = list()
        brilliances = list()
        if process_curves is True:
            self._flag_brill_processed = True
            for i, source in enumerate(self.sources):
                if (
                    source.source_type != "wiggler"
                    and source.source_type != "bendingmagnet"
                ):
                    input_brilliance = self.brilliances[i][:, :]
                    input_energies = self.energies[i][:, :]
                    if input_energies.shape[0] > 1:
                        energies_, brilliance = (
                            self.calc.process_brilliance_curve(
                                input_energies,
                                input_brilliance,
                                superp_value=superp_value,
                            )
                        )
                    else:
                        input_brilliance_b = input_brilliance[0]
                        input_energies_b = input_energies[0]
                        idx = _np.argsort(input_energies_b)
                        input_energies_b = input_energies_b[idx]
                        input_brilliance_b = input_brilliance_b[idx]
                        energies_ = _np.linspace(
                            _np.min(input_energies_b),
                            _np.max(input_energies_b),
                            2001,
                        )
                        brilliance = _np.interp(
                            energies_, input_energies_b, input_brilliance_b
                        )
                        energies_ = _np.reshape(
                            energies_, (1, _np.shape(energies_)[0])
                        )
                        brilliance = _np.reshape(
                            brilliance, (1, _np.shape(brilliance)[0])
                        )
                else:
                    input_brilliance = _np.array(
                        self.brilliances[i], dtype=float
                    )
                    input_energies = _np.array(self.energies[i], dtype=float)
                    energies_ = _np.linspace(
                        _np.min(input_energies), _np.max(input_energies), 2001
                    )
                    brilliance = _np.interp(
                        energies_, input_energies, input_brilliance
                    )
                    energies_ = _np.reshape(
                        energies_, (1, _np.shape(energies_)[0])
                    )
                    brilliance = _np.reshape(
                        brilliance, (1, _np.shape(brilliance)[0])
                    )

                energies.append(energies_)
                brilliances.append(brilliance)
            energies = _np.array(energies, dtype=object)
            brilliances = _np.array(brilliances, dtype=object)
            self._energies = energies
            self._brilliances = brilliances

        _plt.figure(figsize=figsize)
        colorlist = ["C0", "C1", "C2", "C3", "C4", "C5"]
        for i, source in enumerate(self.sources):
            color = colorlist[i]
            if source.source_type == "bendingmagnet":
                label = source.label
            else:
                label = source.label
                if legend_properties:
                    label += ", λ = {:.1f} mm".format(source.period)
                    label += ", L = {:.1f} m".format(source.source_length)
            for j in _np.arange(self.energies[i].shape[0]):
                if j == 0:
                    _plt.plot(
                        1e-3 * self.energies[i][j, :],
                        self.brilliances[i][j, :],
                        color=color,
                        linewidth=linewidth,
                        alpha=0.9,
                        label=label,
                    )
                else:
                    _plt.plot(
                        1e-3 * self.energies[i][j, :],
                        self.brilliances[i][j, :],
                        color=color,
                        linewidth=linewidth,
                        alpha=0.9,
                    )

        _plt.yscale(yscale)
        _plt.xscale(xscale)

        if xlim:
            _plt.xlim(xlim[0], xlim[1])
        if ylim:
            _plt.ylim(ylim[0], ylim[1])

        _plt.xlabel("Energy [keV]")
        _plt.ylabel("Brilliance [ph/s/0.1%/mm²/mrad²/100mA]")
        _plt.title(title)

        _plt.minorticks_on()
        _plt.tick_params(
            which="both", axis="both", direction="in", top=True, right=True
        )
        _plt.grid(which="major", alpha=0.4)
        _plt.grid(which="minor", alpha=0.2)

        _plt.legend(fontsize=legend_fs)
        _plt.tight_layout()

        if savefig:
            _plt.savefig(figname, dpi=dpi)
        else:
            _plt.show()

    def plot_flux_curve(
        self,
        process_curves=True,
        superp_value=250,
        title="Flux curves",
        xscale="linear",
        yscale="log",
        xlim=[],
        ylim=[],
        linewidth=3,
        savefig=False,
        figsize=(4.5, 3.0),
        figname="flux.png",
        dpi=300,
        legend_fs=10,
        legend_properties=True,
    ):
        """Plot flux curves.

        Args:
            process_curves (bool, optional): If true energy superposition will
             be processed. Defaults to True.
            superp_value (int, optional): Desired value of energy
             superposition. Defaults to 250.
            title (str, optional): Plot title.
            xscale (str, optional): xscale axis
             xscale. Defalts to 'linear'.
            yscale (str, optional): yscale axis
             yscale. Defalts to 'log'.
        """
        if self._flag_flux_processed:
            process_curves = False
        energies = list()
        fluxes = list()
        if process_curves is True:
            self._flag_flux_processed = True
            for i, source in enumerate(self.sources):
                if (
                    source.source_type != "wiggler"
                    and source.source_type != "bendingmagnet"
                ):
                    input_flux = self.fluxes[i][:, :]
                    input_energies = self.energies[i][:, :]
                    if input_energies.shape[0] > 1:
                        energies_, flux = self.calc.process_brilliance_curve(
                            input_energies,
                            input_flux,
                            superp_value=superp_value,
                        )
                    else:
                        input_flux_b = input_flux[0]
                        input_energies_b = input_energies[0]
                        idx = _np.argsort(input_energies_b)
                        input_energies_b = input_energies_b[idx]
                        input_flux_b = input_flux_b[idx]
                        energies_ = _np.linspace(
                            _np.min(input_energies_b),
                            _np.max(input_energies_b),
                            2001,
                        )
                        flux = _np.interp(
                            energies_, input_energies_b, input_flux_b
                        )
                        energies_ = _np.reshape(
                            energies_, (1, _np.shape(energies_)[0])
                        )
                        flux = _np.reshape(flux, (1, _np.shape(flux)[0]))
                else:
                    input_flux = _np.array(self.fluxes[i], dtype=float)
                    input_energies = _np.array(self.energies[i], dtype=float)
                    energies_ = _np.linspace(
                        _np.min(input_energies), _np.max(input_energies), 2001
                    )
                    flux = _np.interp(energies_, input_energies, input_flux)
                    energies_ = _np.reshape(
                        energies_, (1, _np.shape(energies_)[0])
                    )
                    flux = _np.reshape(flux, (1, _np.shape(flux)[0]))

                energies.append(energies_)
                fluxes.append(flux)
            energies = _np.array(energies, dtype=object)
            fluxes = _np.array(fluxes, dtype=object)
            self._energies = energies
            self._fluxes = fluxes

        _plt.figure(figsize=figsize)
        colorlist = ["C0", "C1", "C2", "C3", "C4", "C5"]
        for i, source in enumerate(self.sources):
            color = colorlist[i]
            if source.source_type == "bendingmagnet":
                label = source.label
            else:
                label = source.label
                if legend_properties:
                    label += ", λ = {:.1f} mm".format(source.period)
                    label += ", L = {:.1f} m".format(source.source_length)
            for j in _np.arange(self.energies[i].shape[0]):
                if j == 0:
                    _plt.plot(
                        1e-3 * self.energies[i][j, :],
                        self.fluxes[i][j, :],
                        color=color,
                        linewidth=linewidth,
                        alpha=0.9,
                        label=label,
                    )
                else:
                    _plt.plot(
                        1e-3 * self.energies[i][j, :],
                        self.fluxes[i][j, :],
                        color=color,
                        linewidth=linewidth,
                        alpha=0.9,
                    )

        _plt.yscale(yscale)
        _plt.xscale(xscale)

        if xlim:
            _plt.xlim(xlim[0], xlim[1])
        if ylim:
            _plt.ylim(ylim[0], ylim[1])

        _plt.xlabel("Energy [keV]")
        _plt.ylabel("Flux [ph/s/0.1%/100mA]")
        _plt.title(title)

        _plt.minorticks_on()
        _plt.tick_params(
            which="both", axis="both", direction="in", top=True, right=True
        )
        _plt.grid(which="major", alpha=0.4)
        _plt.grid(which="minor", alpha=0.2)

        _plt.legend(fontsize=legend_fs)
        _plt.tight_layout()

        if savefig:
            _plt.savefig(figname, dpi=dpi)
        else:
            _plt.show()

    def plot_flux_matrix(self):
        """Plot Flux Matrix (period x length)."""
        # Getting the parameters of the best undulator
        info = self._info_matrix[_np.argmax(self._flux_matrix.ravel())]

        period_number = info[1]
        length_number = info[2]

        # Getting the position of the best flux
        j = int(
            _np.argmax(self._flux_matrix.ravel())
            / len(self._flux_matrix[0, :])
        )
        i = _np.argmax(self._flux_matrix.ravel()) % len(
            self._flux_matrix[0, :]
        )

        # Label creation
        label = "Target Energy: {:.2f} KeV\n".format(self._target_energy / 1e3)
        label += "Best undulator: ({:.2f} mm, {:.2f} m)\n".format(
            period_number, length_number
        )
        label += "Flux: {:.2e} ph/s/0.1%/100mA".format(self._flux_matrix[j, i])

        _plt.figure(figsize=(5, 4))
        _plt.title(label)
        _plt.ylabel("Length [m]")
        _plt.xlabel(r"Period [mm]")
        _plt.imshow(
            _np.log(self._flux_matrix),
            extent=[
                self._info_matrix[0, 1],
                self._info_matrix[-1, 1],
                self._info_matrix[-1, 2],
                self._info_matrix[0, 2],
            ],
            aspect="auto",
        )
        _plt.colorbar(label='Flux (log)')

    def get_undulator_from_matrix(self, target_period, target_length):
        """Get information about the target point in matrix.

        Args:
            target_period (float): Undulator period [mm]
            target_length (float): Undulator length [m]

        Returns:
            Numpy array: Undulator informations.
              first element: k number
              second element: undulator period
              third element: undulator length
              fourth element: harmonic number used
            Numpy array: Flux of undulator close to the specified.
        """
        idcs_period = _np.isclose(
            self._info_matrix[:, 1], target_period, rtol=1e-2
        )
        idcs_p = _np.where(idcs_period == True)[0]

        idcs_length = _np.isclose(
            self._info_matrix[idcs_p, 2], target_length, rtol=1e-2
        )
        idcs_l = _np.where(idcs_length == True)[0]

        return (
            self._info_matrix[idcs_p[idcs_l]],
            self._flux_matrix.ravel()[idcs_p[idcs_l]],
        )
