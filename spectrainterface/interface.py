"""Spectra functions."""

import numpy as _np
import matplotlib.pyplot as _plt
from spectrainterface.accelerator import StorageRingParameters
import mathphys
from spectrainterface.tools import SourceFunctions
import json
from spectrainterface import spectra
import sys
import time
import os

# REPOS_PATH = os.path.abspath("./")
# REPOS_PATH = __file__
REPOS_PATH = os.path.dirname(os.path.abspath(__file__))

ECHARGE = mathphys.constants.elementary_charge
EMASS = mathphys.constants.electron_mass
LSPEED = mathphys.constants.light_speed
ECHARGE_MC = ECHARGE / (2 * _np.pi * EMASS * LSPEED)


class SpectraTools:
    """Class with general spectra tools."""

    @staticmethod
    def _run_solver(input_template):
        """Run spectra.

        Args:
            input_template (dict): Dictionary containing
            calculation parameters.

        Returns:
            dict: Output data dictionary
        """
        input_str = json.dumps(input_template)

        # call solver with the input string (JSON format)
        solver = spectra.Solver(input_str)

        # check if the parameter load is OK
        isready = solver.IsReady()
        if isready is False:
            print("Parameter load failed.")
            sys.exit()

        t0 = time.time()
        # start calculation
        solver.Run()
        dt = time.time() - t0
        print("elapsed time: {0:.1f} s".format(dt))
        return solver

    @staticmethod
    def _set_accelerator_config(accelerator, input_template):
        input_template["Accelerator"]["Energy (GeV)"] = accelerator.energy
        input_template["Accelerator"]["Current (mA)"] = accelerator.current

        input_template["Accelerator"]["&sigma;<sub>z</sub> (mm)"] = (
            accelerator.sigmaz
        )

        input_template["Accelerator"]["Nat. Emittance (m.rad)"] = (
            accelerator.nat_emittance
        )

        input_template["Accelerator"]["Coupling Constant"] = (
            accelerator.coupling_constant
        )

        input_template["Accelerator"]["Energy Spread"] = (
            accelerator.energy_spread
        )

        input_template["Accelerator"]["&beta;<sub>x,y</sub> (m)"] = [
            accelerator.betax,
            accelerator.betay,
        ]

        input_template["Accelerator"]["&alpha;<sub>x,y</sub>"] = [
            accelerator.alphax,
            accelerator.alphay,
        ]

        input_template["Accelerator"]["&eta;<sub>x,y</sub> (m)"] = [
            accelerator.etax,
            accelerator.etay,
        ]

        input_template["Accelerator"]["&eta;'<sub>x,y</sub>"] = [
            accelerator.etapx,
            accelerator.etapy,
        ]

        input_template["Accelerator"]["Options"]["Injection Condition"] = (
            accelerator.injection_condition
        )

        input_template["Accelerator"]["Options"]["Zero Emittance"] = (
            accelerator.zero_emittance
        )

        input_template["Accelerator"]["Options"]["Zero Energy Spread"] = (
            accelerator.zero_energy_spread
        )

        return input_template


class GeneralConfigs(SourceFunctions):
    """Class with general configs."""

    class SourceType:
        """Sub class to define source type."""

        user_defined = "userdefined"
        horizontal_undulator = "linearundulator"
        vertical_undulator = "verticalundulator"
        helical_undulator = "helicalundulator"
        elliptic_undulator = "ellipticundulator"
        figure8_undulator = "figure8undulator"
        vertical_figure8_undulator = "verticalfigure8undulator"
        bending_magnet = "bendingmagnet"
        wiggler = "wiggler"

    def __init__(self):
        """Class constructor."""
        self._distance_from_source = 10  # [m]
        self._source_type = self.SourceType.user_defined
        self._field = None
        self._length = None
        self._bx_peak = None
        self._by_peak = None
        self._period = None
        self._kx = None
        self._ky = None
        self._rho = None

    @property
    def source_type(self):
        """Source type.

        Returns:
            CalcConfigs variables: Magnetic field, it can be defined by user or
            generated by spectra.
        """
        return self._source_type

    @property
    def field(self):
        """Magnetic field defined by user.

        Returns:
            numpy array: First column contains longitudinal spatial
            coordinate (z) [mm], second column contais vertical field
            [T], and third column constais horizontal field [T].
        """
        return self._field

    @property
    def length(self):
        """Length of device.

        Returns:
            float: Length [m]
        """
        return self._length

    @property
    def period(self):
        """Insertion device period [mm].

        Returns:
            float: ID's period [mm]
        """
        return self._period

    @property
    def by_peak(self):
        """Insertion device vertical peak field [T].

        Returns:
            float: by peak field [T]
        """
        return self._by_peak

    @property
    def bx_peak(self):
        """Insertion device horizontal peak field [T].

        Returns:
            float: bx peak field [T]
        """
        return self._bx_peak

    @property
    def ky(self):
        """Vertical deflection parameter (Ky).

        Returns:
            float: Vertical deflection parameter
        """
        return self._ky

    @property
    def kx(self):
        """Horizontal deflection parameter (Kx).

        Returns:
            float: Horizontal deflection parameter
        """
        return self._kx

    @property
    def rho(self):
        """Curvature radius.

        Returns:
            float: Curvature radius [m]
        """
        return self._rho

    @property
    def distance_from_source(self):
        """Distance from source.

        Returns:
            float: Distance from source [m]
        """
        return self._distance_from_source

    @source_type.setter
    def source_type(self, value):
        self._source_type = value

    @field.setter
    def field(self, value):
        if self.source_type != self.SourceType.user_defined:
            raise ValueError(
                "Field can only be defined if source type is user_defined."
            )
        else:
            self._field = value

    @length.setter
    def length(self, value):
        self._length = value

    @period.setter
    def period(self, value):
        if (
            self.source_type == self.SourceType.user_defined
            or self.source_type == self.SourceType.bending_magnet
        ):
            raise ValueError(
                "Period can only be defined if source type is not user_defined or is not a bending."  # noqa: E501
            )
        else:
            self._period = value
            if self._bx_peak is not None:
                self._kx = 1e-3 * ECHARGE_MC * self._bx_peak * self.period
            if self._by_peak is not None:
                self._ky = 1e-3 * ECHARGE_MC * self._by_peak * self.period
            if self._kx is not None:
                self._bx_peak = self._kx / (ECHARGE_MC * 1e-3 * self.period)
            if self._ky is not None:
                self._by_peak = self._ky / (ECHARGE_MC * 1e-3 * self.period)

    @by_peak.setter
    def by_peak(self, value):
        if self.source_type == self.SourceType.user_defined:
            raise ValueError(
                "By peak can only be defined if source type is not user_defined."  # noqa: E501
            )
        elif self.source_type == self.SourceType.vertical_undulator:
            raise ValueError(
                "By peak can not be defined if source type is a vertical undulator."  # noqa: E501
            )
        else:
            self._by_peak = value
            if self.period is not None:
                self._ky = 1e-3 * ECHARGE_MC * self._by_peak * self.period
                if (
                    self.source_type
                    == self.SourceType.vertical_figure8_undulator
                ):
                    self._ky *= 2

            if self.source_type == self.SourceType.helical_undulator:
                self._bx_peak = value
                if self.period is not None:
                    self._kx = self.ky

    @bx_peak.setter
    def bx_peak(self, value):
        if self.source_type == self.SourceType.user_defined:
            raise ValueError(
                "Bx peak can only be defined if source type is not user_defined."  # noqa: E501
            )
        elif self.source_type == self.SourceType.horizontal_undulator:
            raise ValueError(
                "Bx peak can not be defined if source type is a horizontal undulator."  # noqa: E501
            )
        else:
            self._bx_peak = value
            if self.period is not None:
                self._kx = 1e-3 * ECHARGE_MC * self._bx_peak * self.period
                if self.source_type == self.SourceType.figure8_undulator:
                    self._kx *= 2

            if self.source_type == self.SourceType.helical_undulator:
                self._by_peak = value
                if self.period is not None:
                    self._ky = self.kx

    @ky.setter
    def ky(self, value):
        if self.source_type == self.SourceType.user_defined:
            raise ValueError(
                "Ky can only be defined if source type is not user_defined."  # noqa: E501
            )
        elif self.source_type == self.SourceType.vertical_undulator:
            raise ValueError(
                "Ky can not be defined if source type is a vertical undulator."
            )  # noqa: E501
        else:
            self._ky = value
            if self.period is not None:
                self._by_peak = self._ky / (ECHARGE_MC * 1e-3 * self.period)
                if (
                    self.source_type
                    == self.SourceType.vertical_figure8_undulator
                ):
                    self._by_peak /= 2

            if self.source_type == self.SourceType.helical_undulator:
                self._kx = value
                if self.period is not None:
                    self._bx_peak = self.bx_peak

    @kx.setter
    def kx(self, value):
        if self.source_type == self.SourceType.user_defined:
            raise ValueError(
                "Kx can only be defined if source type is not user_defined."  # noqa: E501
            )
        elif self.source_type == self.SourceType.horizontal_undulator:
            raise ValueError(
                "Kx can not be defined if source type is a horizontal undulator."  # noqa: E501
            )
        else:
            self._kx = value
            if self.period is not None:
                self._bx_peak = self._kx / (ECHARGE_MC * 1e-3 * self.period)
                if self.source_type == self.SourceType.figure8_undulator:
                    self._bx_peak /= 2

            if self.source_type == self.SourceType.helical_undulator:
                self._kx = value
                if self.period is not None:
                    self._bx_peak = self.bx_peak

    @rho.setter
    def rho(self, value):
        if self.source_type == self.SourceType.bending_magnet:
            self._rho = value
        else:
            raise ValueError(
                "Curvature radius can only be defined if source is a bending magnet."  # noqa: E501
            )

    @distance_from_source.setter
    def distance_from_source(self, value):
        self._distance_from_source = value


class Calc(GeneralConfigs, SpectraTools):
    """Class with methods to calculate flux."""

    class CalcConfigs:
        """Sub class to define calculation parameters."""

        class Method:
            """Sub class to define calculation method."""

            near_field = "nearfield"
            far_field = "farfield"
            wigner = "wigner"

        class Variable:
            """Sub class to define independet variable."""

            energy = "en"
            mesh_xy = "xy"
            k = "k"

        class Output:
            """Sub class to define output type."""

            flux_density = "fluxdensity"
            flux = "partialflux"
            brilliance = "brilliance"

        class SlitShape:
            """Sub class to define slit shape."""

            none = ""
            circular = "circslit"
            rectangular = "retslit"

    def __init__(self, accelerator):
        """Class constructor."""
        super().__init__()
        self._method = self.CalcConfigs.Method.near_field
        self._indep_var = self.CalcConfigs.Variable.energy
        self._output_type = self.CalcConfigs.Output.flux_density
        self._slit_shape = self.CalcConfigs.SlitShape.none
        self._accelerator = accelerator
        self._input_template = None

        # Energy related
        self._energy_range = None
        self._energy_step = None
        self._slit_position = None
        self._slit_acceptance = None

        #  Mesh xy related
        self._target_energy = None
        self._x_range = None
        self._y_range = None
        self._x_nr_pts = None
        self._y_nr_pts = None

        #  K related
        self._harmonic_range = None
        self._k_range = None
        self._k_nr_pts = None
        self._slice_x = None
        self._slice_y = None
        self._slice_px = None
        self._slice_py = None

        #  Phase error
        self._add_phase_error = None
        self._random_seed = None
        self._rms_peak_field_var = None
        self._rms_phase_error = None
        self._rms_traj_error = None

        # Output
        self._output_captions = None
        self._output_data = None
        self._output_variables = None

        self._flux = None
        self._brilliance = None
        self._pl = None
        self._pc = None
        self._pl45 = None
        self._energies = None
        self._x = None
        self._y = None
        self._k = None
        self._output_kx = None
        self._output_ky = None

    @property
    def method(self):
        """Method of calculation.

        Returns:
            CalcConfigs variables: Method of calculation, it can be near field
            or wigner functions, for example.
        """
        return self._method

    @property
    def indep_var(self):
        """Independent variable.

        Returns:
            CalcConfigs variables: Independet variable, it can be energy of a
            mesh in the xy plane
        """
        return self._indep_var

    @property
    def output_type(self):
        """Output type.

        Returns:
            CalcConfigs variables: Output type, it can be flux density or
            partial flux, for example.
        """
        return self._output_type

    @property
    def energy_range(self):
        """Energy range.

        Returns:
            List of ints: Energy range to calculate spectrum
             [initial point, final point].
        """
        return self._energy_range

    @property
    def energy_step(self):
        """Energy step.

        Returns:
            float: Spectrum energy step.
        """
        return self._energy_step

    @property
    def observation_angle(self):
        """Observation position [mrad].

        Returns:
            List of floats: Slit position [xpos, ypos] [mrad]
        """
        return self._slit_position

    @property
    def slit_acceptance(self):
        """Slit acceptance [mrad].

        Returns:
            List of floats: Slit acceptance [xpos, ypos] [mrad]
        """
        return self._slit_acceptance

    @property
    def slit_shape(self):
        """Slit shape.

        Returns:
            string: It can be circular or rectangular.
        """
        return self._slit_shape

    @property
    def target_energy(self):
        """Target energy.

        Returns:
            float: Target energy to analyse.
        """
        return self._target_energy

    @property
    def x_range(self):
        """Mesh x range.

        Returns:
            List of floats: x limits [mrad] [initial point, final point]
        """
        return self._x_range

    @property
    def y_range(self):
        """Mesh y range.

        Returns:
            List of floats: y limits [mrad] [initial point, final point]
        """
        return self._y_range

    @property
    def x_nr_pts(self):
        """Nr of x points.

        Returns:
            float: Number of horizontal mesh points
        """
        return self._x_nr_pts

    @property
    def y_nr_pts(self):
        """Nr of y points.

        Returns:
            float: Number of vertical mesh points
        """
        return self._y_nr_pts

    @property
    def harmonic_range(self):
        """Harmonic range.

        Returns:
            list of ints: List of harmonics to calculate brilliance.
        """
        return self._harmonic_range

    @property
    def k_range(self):
        """K range.

        Returns:
            list of ints: List of k to calculate brilliance [kmin, kmax].
        """
        return self._k_range

    @property
    def k_nr_pts(self):
        """Number of k points.

        Returns:
            int: Number of K points.
        """
        return self._k_nr_pts

    @property
    def slice_x(self):
        """Slice x.

        Returns:
            float: Horizontal source point where Wigner function is
             calculated [mm].
        """
        return self._slice_x

    @property
    def slice_y(self):
        """Slice y.

        Returns:
            float: Vertical source point where Wigner function is
             calculated [mm].
        """
        return self._slice_y

    @property
    def slice_px(self):
        """Slice x'.

        Returns:
            float: Horizontal source angle where Wigner function is
             calculated [mrad].
        """
        return self._slice_px

    @property
    def slice_py(self):
        """Slice y'.

        Returns:
            float: Horizontal source angle where Wigner function is
             calculated [mrad].
        """
        return self._slice_py

    @property
    def output_captions(self):
        """Output captions.

        Returns:
            dict: Captions with spectra output
        """
        return self._output_captions

    @property
    def output_data(self):
        """Output data.

        Returns:
            dict: Data output from spectra
        """
        return self._output_data

    @property
    def output_variables(self):
        """Output variables.

        Returns:
            dict: Variables from spectra
        """
        return self._output_variables

    @property
    def add_phase_error(self):
        """Add phase error.

        Returns:
            bool: If true user can set phase errors.
        """
        return self._add_phase_error

    @property
    def random_seed(self):
        """Random phase error seed.

        Returns:
            float: Seed for generation of phase errors.
        """
        return self._random_seed

    @property
    def rms_peak_field_var(self):
        """RMS of the peak field variation.

        Returns:
            float: RMS of peak field variation.
        """
        return self._rms_peak_field_var

    @property
    def rms_phase_error(self):
        """RMS of phase error.

        Returns:
            float: RMS of phase error.
        """
        return self._rms_phase_error

    @property
    def rms_trajectory_error(self):
        """RMS of trajectory error.

        Returns:
            list of float: RMS of trajectory error [x, y].
        """
        return self._rms_traj_error

    @property
    def flux(self):
        """Flux output.

        Returns:
            numpy array: Flux [ph/s/mr²/0.1%B.W].
        """
        return self._flux

    @property
    def brilliance(self):
        """Brilliance output.

        Returns:
            numpy array: Brilliance [ph/s/mr²/0.1%B.W/mm²].
        """
        return self._brilliance

    @property
    def pl(self):
        """Linear polarization.

        Returns:
            numpy array: Linear polarization s1/s0
        """
        return self._pl

    @property
    def pc(self):
        """Circular polarization.

        Returns:
            numpy array: Circular polarization s3/s0
        """
        return self._pc

    @property
    def pl45(self):
        """Linear polarization 45°.

        Returns:
            numpy array: Linear polarization 45° s2/s0
        """
        return self._pl45

    @property
    def energies(self):
        """Energies.

        Returns:
            numpy array: Energyes [eV]
        """
        return self._energies

    @property
    def x(self):
        """Horizontal angle.

        Returns:
            numpy array: Horizontal angle [mrad]
        """
        return self._x

    @property
    def y(self):
        """Vertical angle.

        Returns:
            numpy array: Vertical angle [mrad]
        """
        return self._y

    @property
    def k(self):
        """Deflection parameter K.

        Returns:
            numpy array: Deflecetion parameter K.
        """
        return self._k

    @property
    def output_kx(self):
        """Deflection parameter Kx.

        Returns:
            numpy array: Deflecetion parameter Kx.
        """
        return self._kx

    @property
    def output_ky(self):
        """Deflection parameter Ky.

        Returns:
            numpy array: Deflecetion parameter Ky.
        """
        return self._ky

    @method.setter
    def method(self, value):
        self._method = value

    @indep_var.setter
    def indep_var(self, value):
        self._indep_var = value
        if value == self.CalcConfigs.Variable.energy:
            self._slit_position = [0, 0]
        elif value == self.CalcConfigs.Variable.mesh_xy:
            self._slit_position = None
            self._slit_shape = self.CalcConfigs.SlitShape.none

    @output_type.setter
    def output_type(self, value):
        self._output_type = value
        if value == self.CalcConfigs.Output.flux_density:
            self._slit_shape = self.CalcConfigs.SlitShape.none

    @energy_range.setter
    def energy_range(self, value):
        if self.indep_var != self.CalcConfigs.Variable.energy:
            raise ValueError(
                "Energy range can only be defined if the independent variable is energy."  # noqa: E501
            )
        else:
            self._energy_range = value

    @energy_step.setter
    def energy_step(self, value):
        if self.indep_var != self.CalcConfigs.Variable.energy:
            raise ValueError(
                "Energy step can only be defined if the independent variable is energy."  # noqa: E501
            )
        else:
            self._energy_step = value

    @observation_angle.setter
    def observation_angle(self, value):
        if self.indep_var != self.CalcConfigs.Variable.energy:
            raise ValueError(
                "Observation position can only be defined if the independent variable is energy."  # noqa: E501
            )
        else:
            self._slit_position = value

    @slit_acceptance.setter
    def slit_acceptance(self, value):
        if self.output_type != self.CalcConfigs.Output.flux:
            if self.source_type == self.SourceType.bending_magnet:
                self._slit_acceptance = value
            else:
                raise ValueError(
                    "Slit acceptance can only be defined if the output type is flux."  # noqa: E501
                )
        else:
            self._slit_acceptance = value

    @slit_shape.setter
    def slit_shape(self, value):
        if self.output_type != self.CalcConfigs.Output.flux:
            raise ValueError(
                "Slit shape can only be defined if the output type is flux."  # noqa: E501
            )
        else:
            self._slit_shape = value

    @target_energy.setter
    def target_energy(self, value):
        if self.indep_var != self.CalcConfigs.Variable.mesh_xy:
            raise ValueError(
                "Target energy can only be defined if the variable is a xy mesh."  # noqa: E501
            )
        else:
            self._target_energy = value

    @x_range.setter
    def x_range(self, value):
        if self.indep_var != self.CalcConfigs.Variable.mesh_xy:
            raise ValueError(
                "X range can only be defined if the variable is a xy mesh."  # noqa: E501
            )
        else:
            self._x_range = value

    @y_range.setter
    def y_range(self, value):
        if self.indep_var != self.CalcConfigs.Variable.mesh_xy:
            raise ValueError(
                "Y range can only be defined if the variable is a xy mesh."  # noqa: E501
            )
        else:
            self._y_range = value

    @x_nr_pts.setter
    def x_nr_pts(self, value):
        if self.indep_var != self.CalcConfigs.Variable.mesh_xy:
            raise ValueError(
                "X range can only be defined if the variable is a xy mesh."  # noqa: E501
            )
        else:
            self._x_nr_pts = value

    @y_nr_pts.setter
    def y_nr_pts(self, value):
        if self.indep_var != self.CalcConfigs.Variable.mesh_xy:
            raise ValueError(
                "Y range can only be defined if the variable is a xy mesh."  # noqa: E501
            )
        else:
            self._y_nr_pts = value

    @harmonic_range.setter
    def harmonic_range(self, value):
        if self.indep_var != self.CalcConfigs.Variable.k:
            raise ValueError(
                "Harmonic range can only be defined if the variable is k."
            )
        else:
            self._harmonic_range = value

    @k_range.setter
    def k_range(self, value):
        if self.indep_var != self.CalcConfigs.Variable.k:
            raise ValueError(
                "K range can only be defined if the variable is k."
            )
        else:
            self._k_range = value

    @k_nr_pts.setter
    def k_nr_pts(self, value):
        if self.indep_var != self.CalcConfigs.Variable.k:
            raise ValueError(
                "K nr points can only be defined if the variable is k."
            )
        else:
            self._k_nr_pts = value

    @slice_x.setter
    def slice_x(self, value):
        if self.indep_var != self.CalcConfigs.Variable.k:
            raise ValueError(
                "Slice x can only be defined if the variable is k."
            )
        else:
            self._slice_x = value

    @slice_y.setter
    def slice_y(self, value):
        if self.indep_var != self.CalcConfigs.Variable.k:
            raise ValueError(
                "Slice y can only be defined if the variable is k."
            )
        else:
            self._slice_y = value

    @slice_px.setter
    def slice_px(self, value):
        if self.indep_var != self.CalcConfigs.Variable.k:
            raise ValueError(
                "Slice x' can only be defined if the variable is k."
            )
        else:
            self._slice_px = value

    @slice_py.setter
    def slice_py(self, value):
        if self.indep_var != self.CalcConfigs.Variable.k:
            raise ValueError(
                "Slice y' can only be defined if the variable is k."
            )
        else:
            self._slice_py = value

    @add_phase_error.setter
    def add_phase_error(self, value):
        if self.method != self.CalcConfigs.Method.near_field:
            raise ValueError(
                "Phase error can only be defined if the method of calculation is near field"  # noqa: E501
            )
        else:
            self._add_phase_error = value

    @random_seed.setter
    def random_seed(self, value):
        if self.add_phase_error is not True:
            raise ValueError(
                "Phase error's parameters can only be defined if add_phase_error is True"  # noqa: E501
            )
        else:
            self._random_seed = value

    @rms_peak_field_var.setter
    def rms_peak_field_var(self, value):
        if self.add_phase_error is not True:
            raise ValueError(
                "Phase error's parameters can only be defined if add_phase_error is True"  # noqa: E501
            )
        else:
            self._rms_peak_field_var = value

    @rms_phase_error.setter
    def rms_phase_error(self, value):
        if self.add_phase_error is not True:
            raise ValueError(
                "Phase error's parameters can only be defined if add_phase_error is True"  # noqa: E501
            )
        else:
            self._rms_phase_error = value

    @rms_trajectory_error.setter
    def rms_trajectory_error(self, value):
        if self.add_phase_error is not True:
            raise ValueError(
                "Phase error's parameters can only be defined if add_phase_error is True"  # noqa: E501
            )
        else:
            self._rms_traj_error = value

    def set_config(self):  # noqa: C901
        """Set calc config."""
        config_name = REPOS_PATH + "/calculation_parameters/"
        config_name += self.source_type
        config_name += "_"
        config_name += self.method
        config_name += "_"
        config_name += self.indep_var
        config_name += "_"
        config_name += self.output_type

        if self.slit_shape != "":
            config_name += "_"
            config_name += self.slit_shape

        config_name += ".json"

        file = open(config_name)
        input_temp = json.load(file)
        input_temp = self._set_accelerator_config(
            self._accelerator, input_temp
        )

        if self.source_type == self.SourceType.bending_magnet:
            del input_temp["Accelerator"]["Options"]["Zero Energy Spread"]
            del input_temp["Accelerator"]["Options"]["Injection Condition"]

        if self.field is not None:
            data = _np.zeros((3, len(self.field[:, 0])))
            data[0, :] = self.field[:, 0]
            data[1, :] = self.field[:, 1]
            data[2, :] = self.field[:, 2]
            input_temp["Light Source"]["Field Profile"]["data"] = data.tolist()

        if self.ky is not None:
            if (
                self.source_type == self.SourceType.horizontal_undulator
                or self.source_type == self.SourceType.helical_undulator
                or self.source_type == self.SourceType.wiggler
            ):
                input_temp["Light Source"]["K value"] = self.ky

        if self.kx is not None:
            if self.source_type == self.SourceType.vertical_undulator:
                input_temp["Light Source"]["K value"] = self.kx

        if self.kx is not None and self.ky is not None:
            if (
                self.source_type == self.SourceType.elliptic_undulator
                or self.source_type == self.SourceType.figure8_undulator
                or self.source_type
                == self.SourceType.vertical_figure8_undulator
            ):
                input_temp["Light Source"]["K<sub>x,y</sub>"] = [
                    self.kx,
                    self.ky,
                ]

        if self.by_peak is not None:
            if self.source_type == self.SourceType.bending_magnet:
                input_temp["Light Source"]["B (T)"] = self.by_peak
                energy = self._accelerator.energy
                brho = energy * 1e9 * ECHARGE / (ECHARGE * LSPEED)
                rho = brho / self.by_peak
                input_temp["Light Source"]["&rho; (m)"] = rho

            elif self.source_type == self.SourceType.wiggler:
                input_temp["Light Source"]["B (T)"] = self.by_peak

        if self.rho is not None:
            if self.source_type == self.SourceType.bending_magnet:
                input_temp["Light Source"]["&rho; (m)"] = self.rho
                energy = self._accelerator.energy
                brho = energy * 1e9 * ECHARGE / (ECHARGE * LSPEED)
                by = brho / self.rho
                input_temp["Light Source"]["B (T)"] = by

        if self.period is not None:
            input_temp["Light Source"]["&lambda;<sub>u</sub> (mm)"] = (
                self.period
            )

        if self.length is not None:
            if self.source_type == self.SourceType.bending_magnet:
                input_temp["Light Source"]["BM Length (m)"] = self.length
            else:
                input_temp["Light Source"]["Device Length (m)"] = self.length

        if self.energy_range is not None:
            input_temp["Configurations"]["Energy Range (eV)"] = (
                self.energy_range
            )

        if self.energy_step is not None:
            if (
                self.source_type == self.SourceType.bending_magnet
                or self.source_type == self.SourceType.wiggler
            ):
                nr_points = int(
                    (self.energy_range[1] - self.energy_range[0])
                    / self.energy_step
                )
                input_temp["Configurations"]["Points (Energy)"] = nr_points
            else:
                input_temp["Configurations"]["Energy Pitch (eV)"] = (
                    self.energy_step
                )

        if self.observation_angle is not None:
            if self.output_type == self.CalcConfigs.Output.flux_density:
                input_temp["Configurations"][
                    "Angle &theta;<sub>x,y</sub> (mrad)"
                ] = self.observation_angle
            elif self.output_type == self.CalcConfigs.Output.flux:
                input_temp["Configurations"][
                    "Slit Pos.: &theta;<sub>x,y</sub> (mrad)"
                ] = self.observation_angle

        if self.slit_acceptance is not None:
            if self.slit_shape == self.CalcConfigs.SlitShape.circular:
                input_temp["Configurations"][
                    "Slit &theta;<sub>1,2</sub> (mrad)"
                ] = self.slit_acceptance
            elif self.slit_shape == self.CalcConfigs.SlitShape.rectangular:
                input_temp["Configurations"][
                    "&Delta;&theta;<sub>x,y</sub> (mrad)"
                ] = self.slit_acceptance
            if self.source_type == self.SourceType.bending_magnet:
                if self.output_type == self.CalcConfigs.Output.flux_density:
                    input_temp["Configurations"]["X' Acceptance (mrad)"] = (
                        self.slit_acceptance
                    )

        if self.target_energy is not None:
            input_temp["Configurations"]["Target Energy (eV)"] = (
                self.target_energy
            )

        if self.x_range is not None:
            input_temp["Configurations"][
                "&theta;<sub>x</sub> Range (mrad)"
            ] = self.x_range
            input_temp["Configurations"][
                "&theta;<sub>y</sub> Range (mrad)"
            ] = self.y_range
            input_temp["Configurations"]["Points (x)"] = self.x_nr_pts
            input_temp["Configurations"]["Points (y)"] = self.y_nr_pts

        if self.harmonic_range is not None:
            input_temp["Configurations"]["Harmonic Range"] = (
                self.harmonic_range
            )
            if (
                self.source_type == self.SourceType.horizontal_undulator
                or self.source_type == self.SourceType.vertical_undulator
                or self.source_type == self.SourceType.helical_undulator
            ):
                input_temp["Configurations"]["K Range"] = self.k_range
            else:
                input_temp["Configurations"]["K<sub>&perp;</sub> Range"] = (
                    self.k_range
                )
            if self.method == self.CalcConfigs.Method.wigner:
                input_temp["Configurations"]["Slice X (mm)"] = self.slice_x
                input_temp["Configurations"]["Slice Y (mm)"] = self.slice_y
                input_temp["Configurations"]["Slice X' (mrad)"] = self.slice_px
                input_temp["Configurations"]["Slice Y' (mrad)"] = self.slice_py
            input_temp["Configurations"]["Points (K)"] = self.k_nr_pts

        input_temp["Configurations"]["Distance from the Source (m)"] = (
            self.distance_from_source
        )

        self._input_template = input_temp

    def verify_valid_parameters(self):  # noqa: C901
        """Check if calculation parameters are valid.

        Returns:
            bool: Returns True of False.
        """
        if self.indep_var == self.CalcConfigs.Variable.energy:
            if self.energy_range is None:
                raise ValueError("Energy range must be defined.")

            if self.energy_step is None:
                raise ValueError("Energy step must be defined.")

            if self.observation_angle is None:
                raise ValueError("Observation angle must be defined.")

            if self.source_type == self.SourceType.bending_magnet:
                if self.slit_acceptance is None:
                    raise ValueError("Slit acceptance must be defined.")

            if self.output_type == self.CalcConfigs.Output.flux:
                if self.slit_acceptance is None:
                    raise ValueError("Slit acceptance must be defined.")

                if self.slit_shape is None:
                    raise ValueError("Slit shape must be defined.")

        if self.indep_var == self.CalcConfigs.Variable.mesh_xy:
            if self.target_energy is None:
                raise ValueError("Energy target must be defined")

            if self.x_range is None:
                raise ValueError("X range must be defined.")

            if self.y_range is None:
                raise ValueError("Y range must be defined.")

            if self.x_nr_pts is None:
                raise ValueError("Nr. of x points must be defined.")

            if self.y_nr_pts is None:
                raise ValueError("Nr. of y points must be defined.")

        if self.indep_var == self.CalcConfigs.Variable.k:
            if self.harmonic_range is None:
                raise ValueError("Harmonic range must be defined.")

            if self.k_range is None:
                raise ValueError("K range must be defined.")

            if self.k_nr_pts is None:
                raise ValueError("Number of K points must be defined.")

            if self.method == self.CalcConfigs.Method.wigner:
                if self.slice_x is None:
                    raise ValueError("Slice x must be defined.")

                if self.slice_y is None:
                    raise ValueError("Slice y must be defined.")

                if self.slice_px is None:
                    raise ValueError("Slice px must be defined.")

                if self.slice_py is None:
                    raise ValueError("Slice py must be defined.")

        return True

    def run_calculation(self):
        """Run calculation."""
        self.verify_valid_parameters()
        solver = self._run_solver(self._input_template)
        # return solver
        captions, data, variables = self.extractdata(solver)
        self._output_captions = captions
        self._output_data = data
        self._output_variables = variables
        self._set_outputs()

    def _set_outputs(self):
        data = self._output_data
        captions = self._output_captions
        variables = self._output_variables

        if self.indep_var == self.CalcConfigs.Variable.energy:
            self._flux = data[0, :]
            if len(captions["titles"]) == 5:
                self._pl = data[1, :]
                self._pc = data[2, :]
                self._pl45 = data[3, :]
            elif len(captions["titles"]) == 6:
                self._brilliance = data[1, :]
                self._pl = data[2, :]
                self._pc = data[3, :]
                self._pl45 = data[4, :]
            self._energies = self._output_variables[0, :]

        elif self.indep_var == self.CalcConfigs.Variable.mesh_xy:
            self._flux = data[0, :]
            self._pl = data[1, :]
            self._pc = data[2, :]
            self._pl45 = data[3, :]

            self._x = self._output_variables[0, :]
            self._y = self._output_variables[1, :]

            self._flux = _np.reshape(self._flux, (len(self._x), len(self._y)))
            self._flux = _np.flip(self._flux, axis=0)

            self._pl = _np.reshape(self._pl, (len(self._x), len(self._y)))
            self._pl = _np.flip(self._pl, axis=0)

            self._pc = _np.reshape(self._pc, (len(self._x), len(self._y)))
            self._pc = _np.flip(self._pc, axis=0)

            self._pl45 = _np.reshape(self._pl45, (len(self._x), len(self._y)))
            self._pl45 = _np.flip(self._pl45, axis=0)

        elif self.indep_var == self.CalcConfigs.Variable.k:
            if self.method == self.CalcConfigs.Method.wigner:
                if (
                    self.source_type != self.SourceType.elliptic_undulator
                    and self.source_type != self.SourceType.figure8_undulator
                    and self.source_type
                    != self.SourceType.vertical_figure8_undulator
                ):
                    self._k = data[:, 0, :]
                    self._brilliance = data[:, 1, :]
                    self._energies = variables[:, :]

                else:
                    self._kx = data[:, 0, :]
                    self._ky = data[:, 1, :]
                    self._brilliance = data[:, 2, :]
                    self._energies = variables[:, :]
            elif self.method == self.CalcConfigs.Method.far_field:
                if (
                    self.source_type != self.SourceType.elliptic_undulator
                    and self.source_type != self.SourceType.figure8_undulator
                    and self.source_type
                    != self.SourceType.vertical_figure8_undulator
                ):
                    self._k = data[:, 1, :]
                    self._flux = data[:, 2, :]
                    self._energies = variables[:, :]
                else:
                    self._kx = data[:, 1, :]
                    self._ky = data[:, 2, :]
                    self._flux = data[:, 3, :]
                    self._energies = variables[:, :]

    def extractdata(self, solver):
        """Extract solver data.

        Args:
            solver (spectra solver): Spectra solver object

        Returns:
            dict: captions
            dict: data
            dict: variables
        """
        captions = solver.GetCaptions()
        data = _np.array(solver.GetData()["data"])
        if self.indep_var != self.CalcConfigs.Variable.k:
            variables = _np.array(solver.GetData()["variables"])
        else:
            if (
                self.source_type == self.SourceType.figure8_undulator
                or self.source_type
                == self.SourceType.vertical_figure8_undulator
            ):
                nr_harmonics = (
                    int((self.harmonic_range[-1] - self.harmonic_range[0]) * 2)
                    + 1
                )
                if self.method == self.CalcConfigs.Method.wigner:
                    data = _np.zeros((nr_harmonics, 3, self.k_nr_pts))
                else:
                    data = _np.zeros((nr_harmonics, 7, self.k_nr_pts))
            else:
                nr_harmonics = (
                    int((self.harmonic_range[-1] - self.harmonic_range[0]) / 2)
                    + 1
                )
                if self.source_type == self.SourceType.elliptic_undulator:
                    if self.method == self.CalcConfigs.Method.wigner:
                        data = _np.zeros((nr_harmonics, 3, self.k_nr_pts))
                    else:
                        data = _np.zeros((nr_harmonics, 7, self.k_nr_pts))
                else:
                    if self.method == self.CalcConfigs.Method.wigner:
                        data = _np.zeros((nr_harmonics, 2, self.k_nr_pts))
                    else:
                        data = _np.zeros((nr_harmonics, 6, self.k_nr_pts))
            variables = _np.zeros((nr_harmonics, self.k_nr_pts))
            for i in range(nr_harmonics):
                variables[i, :] = _np.array(
                    solver.GetDetailData(i)["variables"]
                )
                data[i, :, :] = _np.array(solver.GetDetailData(i)["data"])
        return captions, data, variables

    @staticmethod
    def process_brilliance_curve(
        input_energies, input_brilliance, superp_value=250
    ):
        """Process brilliance curve.

        Args:
            input_energies (numpy 2d array): Array with energies and
             brilliances for each harmonic
            input_brilliance (numpy 2d array): Array with energies and
                brilliances for each harmonic
            superp_value (int, optional): Desired value of energy
             superposition. Defaults to 250.

        Returns:
            _type_: _description_
        """
        flag_pre_processing = False
        harm_nr = input_energies.shape[0]
        energies = _np.zeros((harm_nr, 2001))
        brilliance = _np.zeros((harm_nr, 2001))
        for i in _np.arange(harm_nr - 1):
            if flag_pre_processing is False:
                e_harm = input_energies[i, :]
                b_harm = input_brilliance[i, :]
                idx = _np.argsort(e_harm)
                e_harm = e_harm[idx]
                b_harm = b_harm[idx]
                e_harm_interp = _np.linspace(
                    _np.min(e_harm), _np.max(e_harm), 2001
                )
                b_harm_interp = _np.exp(
                    _np.interp(e_harm_interp, e_harm, _np.log(b_harm))
                )
            else:
                e_harm_interp = energies[i, :]
                b_harm_interp = brilliance[i, :]

            e_next_harm = input_energies[i + 1, :]
            b_next_harm = input_brilliance[i + 1, :]
            idx = _np.argsort(e_next_harm)
            e_next_harm = e_next_harm[idx]
            b_next_harm = b_next_harm[idx]

            e_next_harm_interp = _np.linspace(
                _np.min(e_next_harm), _np.max(e_next_harm), 2001
            )
            b_next_harm_interp = _np.exp(
                _np.interp(
                    e_next_harm_interp, e_next_harm, _np.log(b_next_harm)
                )
            )

            max_e_harm = _np.nanmax(e_harm_interp)
            min_e_harm = _np.nanmin(e_harm_interp)
            max_e_next_harm = _np.nanmax(e_next_harm_interp)
            min_e_next_harm = _np.nanmin(e_next_harm_interp)

            flag_pre_processing = False
            if max_e_harm >= min_e_next_harm:
                flag_pre_processing = True

                min_abs = _np.max((min_e_harm, min_e_next_harm))
                max_abs = _np.min((max_e_harm, max_e_next_harm))
                energy_intersect = _np.linspace(min_abs, max_abs, 2001)

                b_harm_intersect = _np.interp(
                    energy_intersect, e_harm_interp, b_harm_interp
                )
                b_next_harm_intersect = _np.interp(
                    energy_intersect, e_next_harm_interp, b_next_harm_interp
                )

                idcs_bigger = _np.where(
                    b_next_harm_intersect >= b_harm_intersect
                )

                ecross = energy_intersect[_np.min(idcs_bigger)]

                idx_cut_e1 = _np.nanargmin(
                    _np.abs(e_harm_interp - ecross - superp_value)
                )
                idx_cut_e3 = _np.nanargmin(
                    _np.abs(e_next_harm_interp - ecross + superp_value)
                )

                e_harm = e_harm_interp[:idx_cut_e1]
                b_harm = b_harm_interp[:idx_cut_e1]

                e_next_harm = e_next_harm_interp[idx_cut_e3:]
                b_next_harm = b_next_harm_interp[idx_cut_e3:]

            e_harm_new = _np.copy(e_harm)
            b_harm_new = _np.copy(b_harm)
            e_harm_new.resize(2001)
            b_harm_new.resize(2001)
            idx = len(e_harm) - 1
            e_harm_new[idx:] = _np.full(len(e_harm_new[idx:]), _np.nan)
            b_harm_new[idx:] = _np.full(len(e_harm_new[idx:]), _np.nan)

            e_next_harm_new = _np.copy(e_next_harm)
            b_next_harm_new = _np.copy(b_next_harm)
            e_next_harm_new.resize(2001)
            b_next_harm_new.resize(2001)
            idx = len(e_next_harm) - 1
            e_next_harm_new[idx:] = _np.full(
                len(e_next_harm_new[idx:]), _np.nan
            )
            b_next_harm_new[idx:] = _np.full(
                len(e_next_harm_new[idx:]), _np.nan
            )

            energies[i, :] = e_harm_new
            brilliance[i, :] = b_harm_new

            energies[i + 1, :] = e_next_harm_new
            brilliance[i + 1, :] = b_next_harm_new

        return energies, brilliance


class SpectraInterface:
    """Spectra Interface class."""

    def __init__(self):
        """Class constructor."""
        self._accelerator = StorageRingParameters()
        self._calc = Calc(self._accelerator)
        self._sources = None
        self._energies = None
        self._brilliances = None
        self._fluxes = None

    @property
    def accelerator(self):
        """Accelerator parameters.

        Returns:
            StorageRingParameters object: class to config accelerator.
        """
        return self._accelerator

    @property
    def calc(self):
        """CalcFlux object.

        Returns:
            CalcFlux object: Class to calculate flux
        """
        return self._calc

    @property
    def sources(self):
        """Sources list.

        Returns:
            List: List of sources objects
        """
        return self._sources

    @property
    def energies(self):
        """List of energies for each undulator.

        Returns:
            list of numpy arrays: Energies for each undulator, for each
             harmonic.
        """
        return self._energies

    @property
    def brilliances(self):
        """List of brilliances for each undulator.

        Returns:
            list of numpy arrays: Brilliances for each undulator, for each
             harmonic.
        """
        return self._brilliances

    @property
    def fluxes(self):
        """List of fluxes for each undulator.

        Returns:
            list of numpy arrays: Fluxes for each undulator, for each
             harmonic.
        """
        return self._fluxes

    @sources.setter
    def sources(self, value):
        self._sources = value

    def calc_brilliance_curve(
        self,
        harmonic_range=[1, 5],
        nr_pts_k=15,
        kmin=0.2,
        emax=20e3,
        x_accep=1,
        beta_sections=None,
    ):
        """Calc brilliance curve.

        Args:
            harmonic_range (list, optional): List of desired harmonics.
             Defaults to [1, 5].
            nr_pts_k (int, optional): Number of k points. Defaults to 15.
            kmin (float): Minimum k value. Defaults to 0.2
            emax (float): Max value of energy for dipoles and wigglers.
            x_accep (float): X acceptance for bending magnet radiation.
            beta_sections (list of string): List of beta sections for each
             source.

        """
        source_list = self.sources
        energies = list()
        brilliances = list()
        for i, source in enumerate(source_list):
            print(
                "Calculating curve for source {:.0f}/{:.0f}".format(
                    i + 1, len(source_list)
                )
            )
            if source.source_type != "bendingmagnet":
                kmax = source.calc_max_k(self.accelerator)

                if source.source_type == "wiggler":
                    b_max = source.undulator_k_to_b(kmax, source.period)
                    self.calc.source_type = self.calc.SourceType.wiggler
                    self.calc.method = self.calc.CalcConfigs.Method.far_field
                    self.calc.indep_var = self.calc.CalcConfigs.Variable.energy
                    self.calc.output_type = (
                        self.calc.CalcConfigs.Output.flux_density
                    )
                    self.calc.period = source.period
                    self.calc.by_peak = b_max
                    self.calc.ky = kmax
                    self.calc.observation_angle = [0, 0]
                    self.calc.energy_range = [1, emax]
                    self.calc.energy_step = 50
                else:
                    self.calc.output_type = (
                        self.calc.CalcConfigs.Output.brilliance
                    )
                    self.calc.indep_var = self.calc.CalcConfigs.Variable.k
                    self.calc.method = self.calc.CalcConfigs.Method.wigner
                    self.calc.slice_x = 0
                    self.calc.slice_px = 0
                    self.calc.slice_y = 0
                    self.calc.slice_py = 0
                    self.calc.harmonic_range = harmonic_range
                    self.calc.k_nr_pts = nr_pts_k

                    polarization = source.polarization
                    if polarization == "hp":
                        self.calc.source_type = (
                            self.calc.SourceType.horizontal_undulator
                        )
                    elif polarization == "vp":
                        self.calc.source_type = (
                            self.calc.SourceType.vertical_undulator
                        )
                    elif polarization == "cp":
                        self.calc.source_type = (
                            self.calc.SourceType.elliptic_undulator
                        )
                    else:
                        return

                    self.calc.k_range = [kmin, kmax]
                    self.calc.period = source.period
                    self.calc.by_peak = 1
            else:
                b = source.b_peak
                self.calc.source_type = self.calc.SourceType.bending_magnet
                self.calc.method = self.calc.CalcConfigs.Method.far_field
                self.calc.indep_var = self.calc.CalcConfigs.Variable.energy
                self.calc.slit_acceptance = x_accep
                self.calc.output_type = (
                    self.calc.CalcConfigs.Output.flux_density
                )
                self.calc.by_peak = b
                self.calc.observation_angle = [0, 0]
                self.calc.energy_range = [1, emax]
                self.calc.energy_step = 50

            self.calc.length = source.source_length

            if beta_sections is not None:
                if beta_sections[i] == "high":
                    self.accelerator.set_high_beta_section()
                elif beta_sections[i] == "low":
                    self.accelerator.set_low_beta_section()
                elif beta_sections[i] == "b2":
                    self.accelerator.set_b2_section()
                elif beta_sections[i] == "bc":
                    self.accelerator.set_bc_section()
                else:
                    raise ValueError("Invalid beta section.")

            self.calc.set_config()
            self.calc.run_calculation()

            energies.append(self.calc.energies)
            brilliances.append(self.calc.brilliance)

        energies = _np.array(energies)
        brilliances = _np.array(brilliances)
        self._energies = energies
        self._brilliances = brilliances

    def calc_flux_curve(
        self,
        energy_range=[1, 5],
        harmonic_range=[1, 5],
        nr_pts_k=15,
        kmin=0.2,
        slit_shape="circslit",
        slit_acceptance=[0, 0.04],
        beta_sections=None,
    ):
        source_list = self.sources
        energies = list()
        fluxes = list()
        for i, source in enumerate(source_list):
            print(
                "Calculating curve for source {:.0f}/{:.0f}".format(
                    i + 1, len(source_list)
                )
            )
            if source.source_type != "bendingmagnet":
                kmax = source.calc_max_k(self.accelerator)

                if source.source_type == "wiggler":
                    b_max = source.undulator_k_to_b(kmax, source.period)
                    self.calc.source_type = self.calc.SourceType.wiggler
                    self.calc.method = self.calc.CalcConfigs.Method.far_field
                    self.calc.indep_var = self.calc.CalcConfigs.Variable.energy
                    self.calc.output_type = self.calc.CalcConfigs.Output.flux
                    self.calc.slit_shape = slit_shape
                    self.calc.period = source.period
                    self.calc.by_peak = b_max
                    self.calc.ky = kmax
                    self.calc.observation_angle = [0, 0]
                    self.calc.slit_acceptance = slit_acceptance
                    self.calc.energy_range = energy_range
                    self.calc.energy_step = 1
                else:
                    self.calc.output_type = self.calc.CalcConfigs.Output.flux
                    self.calc.indep_var = self.calc.CalcConfigs.Variable.k
                    self.calc.method = self.calc.CalcConfigs.Method.far_field
                    self.calc.slit_shape = slit_shape
                    self.calc.harmonic_range = harmonic_range
                    self.calc.k_nr_pts = nr_pts_k

                    polarization = source.polarization
                    if polarization == "hp":
                        self.calc.source_type = (
                            self.calc.SourceType.horizontal_undulator
                        )
                    elif polarization == "vp":
                        self.calc.source_type = (
                            self.calc.SourceType.vertical_undulator
                        )
                    elif polarization == "cp":
                        self.calc.source_type = (
                            self.calc.SourceType.elliptic_undulator
                        )
                    else:
                        return

                    self.calc.k_range = [kmin, kmax]
                    self.calc.period = source.period
                    self.calc.by_peak = 1
            else:
                b = source.b_peak
                self.calc.source_type = self.calc.SourceType.bending_magnet
                self.calc.method = self.calc.CalcConfigs.Method.far_field
                self.calc.indep_var = self.calc.CalcConfigs.Variable.energy
                self.calc.output_type = self.calc.CalcConfigs.Output.flux
                self.calc.slit_shape = slit_shape
                self.calc.observation_angle = [0, 0]
                self.calc.slit_acceptance = slit_acceptance
                self.calc.energy_range = energy_range
                self.calc.energy_step = 1
                self.calc.by_peak = b

            self.calc.length = source.source_length

            if beta_sections is not None:
                if beta_sections[i] == "high":
                    self.accelerator.set_high_beta_section()
                elif beta_sections[i] == "low":
                    self.accelerator.set_low_beta_section()
                elif beta_sections[i] == "b2":
                    self.accelerator.set_b2_section()
                elif beta_sections[i] == "bc":
                    self.accelerator.set_bc_section()
                else:
                    raise ValueError("Invalid beta section.")

            self.calc.set_config()
            self.calc.run_calculation()

            energies.append(self.calc.energies)
            fluxes.append(self.calc.flux)

        energies = _np.array(energies)
        fluxes = _np.array(fluxes)

        self._energies = energies
        self._fluxes = fluxes

    def plot_brilliance_curve(
        self, process_curves=True, superp_value=250, title="Brilliance curves"
    ):
        """Plot brilliance curves.

        Args:
            process_curves (bool, optional): If true energy superposition will
             be processed. Defaults to True.
            superp_value (int, optional): Desired value of energy
             superposition. Defaults to 250.
            title (str, optional): Plot title.
        """
        energies = list()
        brilliances = list()
        if process_curves is True:
            for i, source in enumerate(self.sources):
                if (
                    source.source_type != "wiggler"
                    and source.source_type != "bendingmagnet"
                ):
                    input_brilliance = self.brilliances[i][:, :]
                    input_energies = self.energies[i][:, :]
                    energies_, brilliance = self.calc.process_brilliance_curve(
                        input_energies,
                        input_brilliance,
                        superp_value=superp_value,
                    )
                else:
                    input_brilliance = self.brilliances[i]
                    input_energies = self.energies[i]
                    energies_ = _np.linspace(
                        _np.min(input_energies), _np.max(input_energies), 2001
                    )
                    brilliance = _np.interp(
                        energies_, input_energies, input_brilliance
                    )
                    energies_ = _np.reshape(
                        energies_, (1, _np.shape(energies_)[0])
                    )
                    brilliance = _np.reshape(
                        brilliance, (1, _np.shape(brilliance)[0])
                    )

                energies.append(energies_)
                brilliances.append(brilliance)
            energies = _np.array(energies)
            brilliances = _np.array(brilliances)
            self._energies = energies
            self._brilliances = brilliances

        _plt.figure(figsize=(4.5, 3.0))
        colorlist = ["C0", "C1", "C2", "C3", "C4", "C5"]
        for i, source in enumerate(self.sources):
            color = colorlist[i]
            if source.source_type == "bendingmagnet":
                label = source.label
            else:
                label = source.label
                label += ", λ = {:.1f} mm".format(source.period)
                label += ", L = {:.1f} m".format(source.source_length)
            for j in _np.arange(self.energies[i].shape[0]):
                if j == 0:
                    _plt.plot(
                        self.energies[i][j, :],
                        self.brilliances[i][j, :],
                        color=color,
                        linewidth=3,
                        alpha=0.9,
                        label=label,
                    )
                else:
                    _plt.plot(
                        self.energies[i][j, :],
                        self.brilliances[i][j, :],
                        color=color,
                        linewidth=3,
                        alpha=0.9,
                    )
        _plt.minorticks_on()
        _plt.yscale("log")

        _plt.xlabel("Energy [keV]")
        _plt.ylabel("Brilliance [ph/s/0.1%/mm²/mrad²/100mA]")
        _plt.title(title)

        _plt.tick_params(
            which="both", axis="both", direction="in", top=True, right=True
        )
        _plt.grid(which="major", alpha=0.4)
        _plt.grid(which="minor", alpha=0.2)

        _plt.legend()
        _plt.tight_layout()

        _plt.show()

    def plot_flux_curve(
        self, process_curves=True, superp_value=250, title="Flux curves"
    ):
        """Plot flux curves.

        Args:
            process_curves (bool, optional): If true energy superposition will
             be processed. Defaults to True.
            superp_value (int, optional): Desired value of energy
             superposition. Defaults to 250.
            title (str, optional): Plot title.
        """
        energies = list()
        fluxes = list()
        if process_curves is True:
            for i, source in enumerate(self.sources):
                if (
                    source.source_type != "wiggler"
                    and source.source_type != "bendingmagnet"
                ):
                    input_flux = self.fluxes[i][:, :]
                    input_energies = self.energies[i][:, :]
                    energies_, flux = self.calc.process_brilliance_curve(
                        input_energies,
                        input_flux,
                        superp_value=superp_value,
                    )
                else:
                    input_flux = self.fluxes[i]
                    input_energies = self.energies[i]
                    energies_ = _np.linspace(
                        _np.min(input_energies), _np.max(input_energies), 2001
                    )
                    flux = _np.interp(energies_, input_energies, input_flux)
                    energies_ = _np.reshape(
                        energies_, (1, _np.shape(energies_)[0])
                    )
                    flux = _np.reshape(flux, (1, _np.shape(flux)[0]))

                energies.append(energies_)
                fluxes.append(flux)
            energies = _np.array(energies)
            fluxes = _np.array(fluxes)
            self._energies = energies
            self._fluxes = fluxes

        _plt.figure(figsize=(4.5, 3.0))
        colorlist = ["C0", "C1", "C2", "C3", "C4", "C5"]
        for i, source in enumerate(self.sources):
            color = colorlist[i]
            if source.source_type == "bendingmagnet":
                label = source.label
            else:
                label = source.label
                label += ", λ = {:.1f} mm".format(source.period)
                label += ", L = {:.1f} m".format(source.source_length)
            for j in _np.arange(self.energies[i].shape[0]):
                if j == 0:
                    _plt.plot(
                        self.energies[i][j, :],
                        self.fluxes[i][j, :],
                        color=color,
                        linewidth=3,
                        alpha=0.9,
                        label=label,
                    )
                else:
                    _plt.plot(
                        self.energies[i][j, :],
                        self.fluxes[i][j, :],
                        color=color,
                        linewidth=3,
                        alpha=0.9,
                    )
        _plt.minorticks_on()
        _plt.yscale("log")

        _plt.xlabel("Energy [keV]")
        _plt.ylabel("Flux [ph/s/0.1%/100mA]")
        _plt.title(title)

        _plt.tick_params(
            which="both", axis="both", direction="in", top=True, right=True
        )
        _plt.grid(which="major", alpha=0.4)
        _plt.grid(which="minor", alpha=0.2)

        _plt.legend()
        _plt.tight_layout()

        _plt.show()
